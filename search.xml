<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[字符串中括号配对检查]]></title>
    <url>%2F2018%2F03%2F25%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%8B%AC%E5%8F%B7%E9%85%8D%E5%AF%B9%E6%A3%80%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233import java.util.*;//检验&#123;【】&#125;【】括号匹配public class Main &#123; public static void main(String[] args) &#123; int flag = 1, l; String s = "&#123;([])&#125;"; int num = s.length(); char[] arr = s.toCharArray(); System.out.println(arr); // Stack&lt;&gt; stack; Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for (int i = 0; i &lt; num; i++) &#123; if ('&#123;' == arr[i] || '(' == arr[i] || '[' == arr[i]) &#123; stack.push(arr[i]); &#125; else &#123; if (stack.isEmpty()) &#123; flag = 1; &#125; else &#123; if (('&#125;' == arr[i] &amp;&amp; stack.pop() == '&#123;') || ')' == arr[i] &amp;&amp; stack.pop() == '(' || ']' == arr[i] &amp;&amp; stack.pop() == '[') &#123; stack.pop(); &#125; &#125; &#125; &#125; if (flag == 1 &amp;&amp; stack.isEmpty()) System.out.println("Yes"); else &#123; System.out.println("NO"); &#125; &#125;&#125; Output:12&#123;([])&#125;Yes]]></content>
  </entry>
  <entry>
    <title><![CDATA[图形学简答题和代码题.整理]]></title>
    <url>%2F2017%2F12%2F20%2F%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AE%80%E7%AD%94%E9%A2%98%E5%92%8C%E4%BB%A3%E7%A0%81%E9%A2%98.%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[&#xa0;简答题1、计算机图形系统的组成：计算机系统是计算机硬件、图形输入输出设备、计算机系统软件和图形软件的集合。计算机图形系统由计算机硬件系统（图形计算机平台和图形设备）和软件系统（图形支撑软件、图形应用软件和图形应用数据结构）两部分组成。严格说来，使用系统的人也是这个系统的组成部分。&#xa0;2、计算机图形系统的功能：计算功能、存储功能、对话功能、输入功能、输出功能。&#xa0;3、图形学的应用（课程研究内容）1）图形用户界面2）计算机辅助设计与制造3）事务和商务数据的图形显示4）地形地貌和自然资源的图形显示5）过程控制及系统环境模拟6）电子出版及办公自动化7）计算机动画及广告8）计算机艺术9）科学计算的可视化10）工业模拟11）计算机辅助教学。&#xa0;4．坐标系统为了描述、分析、度量几何物体的大小、形状、位置、方向以及相互之间的各种关系使用 的参考框架叫做坐标系统。&#xa0;5.观察坐标系：观察坐标系通常是以视点的位置为原点，通过用户指定的一个向上的观察向量来定义整 个坐标系统，缺省为左手坐标系，观察坐标系主要用于从观察者的角度对整个世界坐标系内的对象进行重 新定位和描述，从而简化几何物体在投影面的成像的数学推导和计算。&#xa0;6.计算机图形学：用计算机建立、存储、处理某个对象的模型，并根据模型产生该对象图形输出的有关 理论、方法与技术，称为计算机图形学。&#xa0;7.计算机图形标准：计算机图形标准是指图形系统及其相关应用程序中各界面之间进行数据传送和通信的接口标准。&#xa0;8.几何变换：几何变换的基本方法是把变换矩阵作为一个算子，作用到图形一系列顶点的位置矢量，从 而得到这些顶点在几何变换后的新的顶点序列，连接新的顶点序列即可得到变换后的图形。&#xa0;代码题&#xa0;&#xa0;1、圆中点法Void MidpointCircle(int r, int color) { int x,y;float d; x=0; y=r; d=1-r; while(x&lt;y) { drawpixel(x,y,color); if(d&lt;0){ d+ = 2*x+3; x++ }; else{d+ = 2*(x-y) + 5; x++;y--; } }}&#xa0;2、圆Bresenham法circle (xc, yc, radius, c)int xc, yc, radius, c;{ int x, y, p; x=0; y=radius; p=3-2*radius; while (x&lt;y) { plot_circle_points(xc, yc, x, y, c);&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; if (p&lt;0) {p=p+4*x+6;}&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; else{ p=p+4*(x-y)+10;y-=1;}&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; x+=1;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; } if (x= =y) plot_circle_points(xc, yc, x, y, c);}&#xa0;3、椭圆的算法（Bresenham法）viod MidpointEllipe(a,b, color) { int a,b,color; int x,y; float d1,d2;x = 0; y = b;d1 = b*b +a*a*(-b+0.25); ellipesputpixel(x,y,color); while( b*b*(x+1) &lt; a*a*(y-0.5)) //生成上半部分椭圆{ if (d1&lt;0){d1 +=b*b*(2*x+3); x++; } else { d1 +=(b*b*(2*x+3)+a*a*(-2*y+2))x++; y--;} ellipesputpixel(x,y,color);}//上部分 d2 = b*b*(x+0.5)*(x+0.5)+a*a*(y-1)*(y-1)-a*a*b*b; while(y &gt;0) //生成下半部分椭圆 { if (d2 &lt;0) { d2 +=b*b*(2*x+2)+a*a*(-2*y+3);x++; y--；} else {d2 += a*a*(-2*y+3); y--; } ellipesputpixel(x,y,color); }&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;4、DDA的直线算法(1)DDA算法生成直线的基本原理是什么？p105yi=kxi+b;Yi+1=kxi+1+b=yi+k△x；当△x=1，Yi+1=yi+k；|K|≤1；当|K|&gt;1时，x和y互换位置(2) 直线算法Void DDALine(int x0,int y0,int x1,int y1,int color){int x, y,dx,dx,dy,k;x=x0,y=y0;dx = x1-x0;dy=x1-x0;while(x&lt;x1){x++;Drawpixle(x,(int)(y+0.5),c);y=y+K;}}5、微分数值法void DDALine(int x0,int y0,int x1,int yt1,int color) { int i,dx,dy; float xt,yt,a; dx = x1-x0; dy=y1-y0; if(abs(dx)&gt;abs(dy))a=abs(dx); else a=abs(dy); xt=(float)dx/a; Yt=(float)dy/a; for (i=0; i&lt;=a; i++) {drawpixel (int(x+0.5), int(y+0.5), color);x+=xt;y+=yt;}}&#xa0;6、直线中点法void Midpoint Line (int x0,int y0,int xt, int yt,int color){ int dx,dy,x,y,d;dx=xt-x0;dy=yt-y0;x=x0;y=y0;d=2*dx-2*dy;while(x&lt;=xt){ draw(x,y,color); x++; if(d&lt;0){y++; d+=dx-2*dy} else {d+=-2*dy}}}&#xa0;7、直线Bresenham法,试写出能获得整数Bresenham画线算法的c++程序（提示：①假定直线的斜率在0和1之间）。Bresenhamline(int x0,int y0,int x1,int y1){ int x,y,dx,dy,e;Dx=x1-x0;Dy=y1-y0;e=-dx;x=x0;y=y0;while (x&lt;=x1){ putpixel(x,y);x++;e=e+2*dy;If (e&gt;0){ y++; e=e-2*dx;}}}8、写出一个点的二维图形的旋转变换程序（c++）#define PI=3.14void XuanZhuan(){float d=30.0*PI/180.0(这里假设旋转30度);int x=100,y=200;x=x*cos(d)-y*sin(d);y=x*sin(d)+y*cos(d);}&#xa0;8、种子填充算法void FloodFill4(int x,int y,int oldColor,int newColor){ if(GetPixel(x,y) == oldColor) { PutPixel(x,y,newColor); FloodFill4(x,y+1,oldColor,newColor); FloodFill4(x,y-1,oldColor,newColor); FloodFill4(x-1,y,oldColor,newColor); FloodFill4(x+1,y,oldColor,newColor); }} &#xa0;9、平移void CDialog_Translate::OnOK() {UpdateData(true);glClear(GL_COLOR_BUFFER_BIT);glMatrixMode(GL_MODELVIEW);glLoadIdentity();glTranslatef(m_delta_x, m_delta_y, m_delta_z);CDialog::OnOK();}&#xa0;10、比例void CDialog_Scale::OnOK() { UpdateData(true);glClear(GL_COLOR_BUFFER_BIT);glMatrixMode(GL_MODELVIEW);glLoadIdentity();glScalef(m_scale_x, m_scale_y, m_scale_z);CDialog::OnOK();}&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; 关于y=x轴对称 &#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; 关于y=-x轴对称&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; 对称于XOY平面&#xa0;&#xa0;&#xa0;&#xa0;]]></content>
  </entry>
  <entry>
    <title><![CDATA[操作系统复习]]></title>
    <url>%2F2017%2F12%2F06%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[操作系统复习操作系统复习第一章 概述1、操作系统的概念、基本类型、基本特征、基本功能、管态/目态；2、操作系统的目标、作用、结构设计方法；第二章 进程管理1、多道程序设计技术；2、进程的概念、特征、基本状态及与程序的区别和联系；3、PCB的概念、前趋图、进程图；4、原语的概念及进程控制原语的种类；5、进程的同步与互斥的概念、临界资源与临界区的概念；6、信号量及其应用；7、线程的概念及种类、引入线程的目的；第三章 处理机调度与死锁1、调度的层次与作用；2、常用调度算法及计算；3、死锁的概念、产生的原因及必要条件；4、处理死锁的基本方法；5、银行家算法及计算；第四章 存储管理1、存储管理的目的、功能；2、重定位的概念及方法；3、内碎片、外碎片；4、常用分区分配算法及对应的空闲区排列方式；5、基本分页（分段）的概念、页（段）表的作用、地址变换过程及物理地址计算；6、分页与分段的区别、各自的优缺点；第五章 虚拟存储器1、虚拟存储器的基本概念、理论依据、基本特征及关键技术；2、熟知请求分页基本思想；3、页面置换算法、缺页率计算、LRU算法的硬件实现方法、抖动、Belady异常、缺页中断；4、快表的作用、内存访问时间的计算；第六章 设备管理1、设备管理的任务、功能及目标；2、I/O设备的分类，设备、控制器及通道的关系；3、通道的基本概念及分类；4、I/O控制方式及推动发展的因素、各自适用的场合；5、缓冲区的概念、分类及引入目的；单缓冲、双缓冲计算处理数据的时间；6、I/O软件的层次、各层主要功能、设备独立性的概念；7、SPOOLING技术的概念、作用及SPOOLING系统的组成；8、磁盘访问过程及访问时间的确定、磁盘调度算法及其计算；扇区的优化；第七章 文件管理1、文件系统的组成、功能；2、打开、关闭操作的目的；3、文件逻辑结构；4、文件的目录结构、索引节点及文件控制块的作用；5、了解文件的共享和保护措施。第八章 磁盘存储器的管理1、文件的物理结构；2、FAT表的作用、FAT表大小的计算；3、混合索引分配方式的结构及相关计算；4、文件空闲区的管理方法（空闲表、空闲链、位示图与成组链接法）；5、了解提高磁盘I/O速度的途径。&#xa0;]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于MySQL版本问题注意事项MySQL5InnoDBDialect]]></title>
    <url>%2F2017%2F11%2F17%2F%E5%85%B3%E4%BA%8EMySQL%E7%89%88%E6%9C%AC%E9%97%AE%E9%A2%98%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9MySQL5InnoDBDialect%2F</url>
    <content type="text"><![CDATA[报错信息: error：You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘type=InnoDB’ at line XX 这是因为type=InnoDB在5.0以前是可以使用的，但5.1之后就不行了。其实我们把type=InnoDB改为engine=InnoDB就可以了。修改如下：12&lt;!-- 数据库方言配置 org.hibernate.dialect.MySQLDialect (选择最短的) --&gt; &lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQL5InnoDBDialect&lt;/property&gt; 特别注意MySQL5InnoDBDialect中的5！！再次运行，完美.]]></content>
  </entry>
  <entry>
    <title><![CDATA[NASA]]></title>
    <url>%2F2017%2F10%2F27%2FNASA%2F</url>
    <content type="text"><![CDATA[NASA: NASA Exoplanet Exploration]]></content>
  </entry>
  <entry>
    <title><![CDATA[几个经典算法]]></title>
    <url>%2F2017%2F10%2F20%2F%E5%87%A0%E4%B8%AA%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[蛮力算法子集12345678910111213141516171819#include&lt;iostream&gt;using namespace std;#define MAX 1000int main() &#123; int n; int a[MAX]; int tol;//子集的个数 n=4; for(int i=0; i&lt;n; i++) &#123; cin&gt;&gt;a[i]; &#125; tol=(1&lt;&lt;n)-1; //子集的个数 for(int i=0; i&lt;=tol; i++) &#123; for(int j=0; j&lt;n; j++) if(i&amp;(i&lt;&lt;j)) cout&lt;&lt;a[j]; //i&lt;&lt;j相当于对每一个进行标记 cout&lt;&lt;" "&lt;&lt;endl; &#125;&#125; 递归算法1.输出全排列1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;void Perm(int list[],int k,int m) &#123; if(k==m) &#123; for(int i=0; i&lt;=m; i++) cout&lt;&lt;list[i]&lt;&lt;" "; cout&lt;&lt;endl; &#125; else &#123; for(int j=k; j&lt;=m; j++) &#123; swap(list[k],list[j]); Perm(list,k+1,m); swap(list[k],list[j]); &#125; &#125;&#125;int main() &#123; int list[]= &#123;1,2,3,4,5&#125;; Perm(list,0,3);&#125; //正整数n的划分算法1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;int split(int n,int m)&#123; if(n==1||m==1) return 1; else if (n&lt;m) return split(n,n); else if(n==m) return split(n,n-1)+1; else return split(n,m-1)+split(n-m,m);&#125;int main()&#123; int n; while (cin&gt;&gt;n) cout&lt;&lt;split(n, n)&lt;&lt;endl; return 0;&#125; //对一个段进行递归调用 return select(j+1, right, k-j+left-1); else return select(left, j-1, k);&#125;int main()&#123; int n, k; while (cin&gt;&gt;n&gt;&gt;k) &#123; for (int i=0; i&lt;n; i++) cin&gt;&gt;a[i]; cout&lt;&lt;select(0, n-1, k)&lt;&lt;endl; &#125; return 0;&#125; //半数集问题的递归算法12345678910111213141516171819202122232425#include&lt;iostream&gt; using namespace std;int a[1001];int comp(int n)&#123; int ans=1; if(a[n]&gt;0)return a[n]; for(int i=1;i&lt;=n/2;i++) ans+=comp(i); a[n]=ans; return ans;&#125;int main()&#123; int n; while(cin&gt;&gt;n) &#123; memset(a,0,sizeof(a)); a[1]=1; cout&lt;&lt;comp(n)&lt;&lt;endl; &#125; return 0;&#125; 分治算法选择问题//采用分治策略找出第k小元素的算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;iostream&gt;using namespace std;#define NUM 1001int a[NUM];int select(int left, int right, int k)&#123; //找到第k小的元素 if (left &gt;= right) return a[left]; int i = left; int j = right+1; //把最左边的元素作为分界数据 int pivot = a[left]; while (true) &#123; do &#123; i = i+1; &#125; while (a[i] &lt; pivot); do &#123; j = j-1; &#125; while (a[j] &gt; pivot); if (i &gt;= j) break; swap(a[i], a[j]); &#125; if (j-left+1 == k) return pivot; a[left] = a[j]; a[j] = pivot; if (j-left+1 &lt; k) return select(j+1,right,k-j+left-1); else return select(left,j-1,k);&#125; 选择第K个大的数#include&lt;iostream&gt;using namespace std;void swap(int *a, int *b)&#123; int tmp; tmp = *a; *a = *b; *b = tmp;&#125;int partition(int arr[], int left, int right, int pivotIndex)&#123; int storeIndex = left; int pivotValue = arr[pivotIndex]; int i; swap(&amp;arr[pivotIndex],&amp;arr[right]); for (i = left; i &lt; right; i ++) &#123; if (arr[i] &gt; pivotValue) &#123; swap(&amp;arr[i],&amp;arr[storeIndex]); storeIndex++; &#125; &#125; swap(&amp;arr[storeIndex],&amp;arr[right]); return storeIndex;&#125;int findKMax(int arr[], int left, int right, int k)&#123; int nRet; int pivotIndex = left + 1; nRet = partition(arr,left,right,pivotIndex); if (nRet &lt; k) &#123; return findKMax(arr,nRet+1,right,k); &#125; else if (nRet &gt; k) &#123; return findKMax(arr,left,nRet-1,k); &#125; return nRet;&#125;int main()&#123; int i,k,nRet; int arr[] = &#123;8,3,4,1,9,7,6,10&#125;; scanf("%d",&amp;k); nRet = findKMax(arr,0,7,k-1); printf("The Kth Max Number locate in %d is :%d\n",nRet,arr[nRet]); for (i = 0; i &lt; 8; i++) &#123; printf("%3d",arr[i]); &#125; return 0;&#125; /循环赛程表1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#define MAX 100int a[MAX][MAX];void Copy(int tox, int toy, int fromx, int fromy, int r)&#123; for (int i=0; i&lt;r; i++) for (int j=0; j&lt;r; j++) a[tox+i][toy+j] = a[fromx+i][fromy+j];&#125;//构造循环赛日程表，选手的数量n=2^kvoid Table(int k)&#123; int i, r; int n = 1 &lt;&lt; k; //构造正方形表格的第一行数据 for (i=0; i&lt;n; i++) a[0][i] = i + 1; //采用分治算法构造整个循环日程赛表 for (r=1; r&lt;n; r&lt;&lt;=1) for (i=0; i&lt;n; i+=2*r) &#123; Copy(r, i + r, 0, i, r); Copy(r, i, 0, i + r, r); &#125;&#125;void Out(int n)&#123; for (int i=0; i&lt;n; i++) &#123; for (int j=0; j&lt;n; j++) printf("%3d", a[i][j]); printf("\n"); &#125; printf("\n");&#125;int main()&#123; int k; while (scanf("%d", &amp;k) &amp;&amp; k) &#123; int n = 1 &lt;&lt; k; Table(k); Out(n); &#125; return 0;&#125; 动态规划矩阵链乘积1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;int m[100][100];int p[100],s[100][100];int k;int TraceBack(int i,int j) &#123; if(m[i][j]&gt;0) return m[i][j]; if(i==j) return 0; int u=TraceBack(i,i)+TraceBack(i+1,j)+p[i-1]*p[k]*p[j]; s[i][j]=i; for(int k=i+1; k&lt;j; k++) &#123; int t=TraceBack(i,k)+TraceBack(k+1,j)+p[i-1]*p[k]*p[j]; if(t&lt;u) &#123; u=t; s[i][j]=k; &#125; m[i][j]=u; return u; &#125;&#125; 最多单减子序列1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;using namespace std;#define MAX 1000int a[MAX] = &#123;2,1,3&#125;;int select(int left,int right,int k) &#123; if(left&gt;=right) return a[left]; int i =left; int j = right+1; int pivot = a[left]; //把第一个设为界点 while(true) &#123; do &#123; i++; &#125; while(a[i]&lt;pivot); do &#123; j--; &#125; while(a[j]&gt;pivot); if(i&gt;=j) break; swap(a[i],a[j]); &#125; if(j-left+1==k) return pivot; //该界点就是要找的数 a[left]=a[j]; a[j]=pivot; if(j-left+1&lt;k) return select(j+1, right, k-j+left-1); else return select(left,j-1,k);&#125;int main() &#123;// int a[3] = &#123;2,1,3&#125;; cout&lt;&lt;select(0,2,2);&#125; //计算0-1背包的动态规划算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include&lt;ctime&gt;using namespace std;#define NUM 50#define CAP 1500int v[NUM];int w[NUM];int p[NUM][CAP];//形参c是背包的容量w，n是物品的数量void knapsack(int c, int n) &#123; int jMax=min(w[n]-1,c); for( int j=0; j&lt;=jMax; j++) p[n][j]=0; for( int j=w[n]; j&lt;=c; j++) p[n][j]=v[n]; for( int i=n-1; i&gt;1; i--) &#123; jMax=min(w[i]-1,c); for( int j=0; j&lt;=jMax; j++) p[i][j]=p[i+1][j]; for(int j=w[i]; j&lt;=c; j++) p[i][j]=max(p[i+1][j], p[i+1][j-w[i]]+v[i]); &#125; p[1][c]=p[2][c]; if (c&gt;=w[1]) p[1][c]=max(p[1][c], p[2][c-w[1]]+v[1]); &#125; void traceback( int c, int n, int x[ ]) &#123; for(int i=1; i&lt;n; i++) &#123; if (p[i][c]==p[i+1][c]) x[i]=0; else &#123; x[i]=1; c-=w[i]; &#125; &#125; x[n]=(p[n][c])? 1:0; &#125; int main () &#123; int x[NUM]; int W; int n; while (scanf("%d", &amp;W) &amp;&amp; W) &#123; scanf("%d", &amp;n); for (int i=1; i&lt;=n; i++) scanf("%d%d", &amp;w[i], &amp;v[i]); memset (p, 0, sizeof(p)); knapsack(W, n); printf("%d\n", p[1][W]); traceback(W, n, x); for (int i=1; i&lt;=n; i++) if (x[i]) printf("%d ", i); printf("\n"); &#125; return 0;&#125; //计算最大字段和的动态规划算法的最优解1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#define NUM 1001int a[NUM];int MaxSum(int n, int &amp;besti, int &amp;bestj)&#123; int sum=0; int b=0; int begin = 0; for (int i=1;i&lt;=n;i++) &#123; if (b&gt;0) b+=a[i]; else &#123;b=a[i];begin = i;&#125; if (b&gt;sum) &#123; sum = b; besti = begin; bestj = i; &#125; &#125; return sum;&#125;int main() &#123; int n; int besti, bestj; while (scanf("%d", &amp;n) &amp;&amp; n) &#123; besti = 0; bestj = 0; for (int i=1; i&lt;=n; i++) scanf("%d", &amp;a[i]); printf("%d\n", MaxSum(n, besti, bestj)); printf("From %d to %d\n", besti, bestj); &#125; return 0;&#125; 贪心算法//删数问题 ，找最近下降点123456789101112131415161718#include&lt;iostream&gt;#include&lt;String&gt;using namespace std;int main() &#123; string a; int k; cin&gt;&gt;a&gt;&gt;k; if(k&gt;=a.size()) a.erase(); else while(k&gt;0) &#123; int i; for(i=0; (i&lt;a.size()-1)&amp;&amp;a[i]&lt;=a[i+1]; i++); a.erase(i,1); k--; &#125; while(a.size()&gt;1 &amp;&amp; a[0]=='0') a.erase(0,1); cout&lt;&lt;a&lt;&lt;endl;&#125; 删数问题123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; string n; int s,i,x,l,m; while(cin&gt;&gt;n&gt;&gt;s) &#123; i=-1,m=0,x=0; l=n.length(); while(x&lt;s&amp;&amp;m==0) &#123; i++; if(n[i]&gt;n[i+1])//出现递减,删除递减的首数字 &#123; n=n.erase(i,1); x++;// x统计删除数字的个数 i=-1;//从头开始查递减区间 &#125; if(i==l-x-2&amp;&amp;x&lt;s) m=1;//已经无递减区间,m=1脱离循环 &#125; cout&lt;&lt;n.substr(0,l-s+x)&lt;&lt;endl;//只打印剩下的左边l-(s-x)个数字 &#125; return 0; &#125; 回溯算法轮船装载（回溯）12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;using namespace std;#define NUM 100 //解空间树 int n; //集装箱数量int c; //轮船装在数量int w[NUM];//集装箱重量数组int x[NUM];//解向量int r; //剩余集装箱重量int cw; //当前轮船载重量int bestw; //当前最优载重量int bestx[NUM];//当前最优解void Backtrack(int t) &#123; //到达叶子节点 if(t&gt;n) &#123; if(cw&gt;bestw) &#123; //更新最优解 for(int i=1; i&lt;=n; i++) bestx[i] = x[i]; bestw = cw; &#125; return; &#125; //更新剩余集装箱的重量 r-= w[t]; //搜索左子树 if(cw+w[t]&lt;=c) &#123; x[t]=1; \ cw+=w[t]; Backtrack(t+1); cw-=w[t];//恢复 状态 &#125; //搜索右子树 if(cw+r&gt;bestw) &#123; x[t]=0; Backtrack(t+1); &#125; r+= w[t];//恢复状态&#125; N皇后问题123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;#define NUM 20int n=8;int x[NUM]; //记录解向量,列号int sum=0; //解的个数inline bool Place(int t) &#123; int i; for(i=1; i&lt;t; i++) &#123; if((abs(t-i) == abs(x[i]-x[t])) || (x[i]==x[t])) return false; &#125; return true; //只要不满足循环就返回true&#125;void Backtrack(int t) &#123; int i;//叶子节点 if(t&gt;n) &#123; sum++; for(i=1; i&lt;=n; i++) &#123; cout&lt;&lt;x[i]; &#125; cout&lt;&lt;endl; &#125; else &#123; for(i=1; i&lt;=n; i++) &#123; x[t]=i; if(Place(t)) Backtrack(t+1); &#125; &#125;&#125;int main() &#123; //cin&gt;&gt;n; Backtrack(1); cout&lt;&lt;"Total="&lt;&lt;sum&lt;&lt;endl;&#125; 分支限界算法装载问题分支限界算法的实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;#define NUM 100int n;//集装箱的数量int c;//轮船的载重量int w[NUM];////集装箱的重量数组int MaxLoading()&#123; queue&lt;int&gt; Q; Q.push(-1); int i = 0; int Ew = 0; int bestw = 0; int r = 0; for(int j=1; j&lt;n; j++) r += w[j]; while (true) &#123; int wt = Ew+w[i]; if (wt&lt;=c) &#123; if (wt&gt;bestw) bestw = wt; if (i&lt;n-1) Q.push(wt); &#125; if (Ew+r&gt;bestw &amp;&amp; i&lt;n-1) Q.push(Ew); Ew = Q.front(); Q.pop(); if (Ew==-1) &#123; if (Q.empty()) return bestw; Q.push(-1); Ew = Q.front(); Q.pop(); i++; r -= w[i]; &#125; &#125; return bestw;&#125;int main()&#123; while(scanf("%d%d", &amp;c, &amp;n)!=EOF) &#123; for(int i=0; i&lt;n; i++) scanf("%d",&amp;w[i]); int ans = MaxLoading(); if (ans) printf("%d\n", ans); else printf("No answer!\n"); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[LOST&FOUND]]></title>
    <url>%2F2017%2F10%2F08%2F%E8%A4%90%E8%89%B2%E9%B8%9F%E7%BE%A4%2F</url>
    <content type="text"><![CDATA[褐色鸟群 作者： 格非 眼下，季节这条大船似乎已经搁浅了。黎明和日暮仍像祖父的步履一样更替。我蛰居在一个被人称作“水边”的地域，写一部类似圣约翰预言的书。我想把它献给我从前的恋人。她在三十岁生日的烛光晚会上过于激动，患脑血栓，不幸逝世。从那以后，我就再也没有见过她。 “水边”这一带，正像我在那本书里记述的一样，天天晴空万里，光线的能见度很好。我坐在寓所的窗口，能够清晰地看见远处水底各种颜色的鹅卵石，以及白如积雪的茅穗上甲壳状或蛾状微生物爬行的姿势。但是我无法分辨季节的变化。我每天都能从寓所屋顶的黑瓦上发现一层白霜。这些霜在中午温暖的太阳光渐渐增强了它的热度时，才化成水从屋檐滴落。这个地带从未下过一场雨。另外，在漆黑如鸦的深夜我还能观察到一些奇异的天象，诸如流星作匀速四周运动，月亮成为不规则的樱桃形等等。我想如果不是我的记忆出现了梗阻，那一定是时间出了毛病。幸好，每天都有一些褐色的候鸟从水边的上空飞过，我能够根据这些褐色的鸟飞动的方向（往南或往北），隐约猜测时序的嬗递。就像我记忆中某个医生曾声称“血是受伤的符号“一样，我以为，候鸟则是季节的符号。 我的书写得很慢。因为我总担心那些褐色的鸟群有一天会不再出现，我想，这些鸟群的消失会把时间一同带走。我的忧虑和潜心谛听常常使我写作分心，甚至剥夺了我在静心写作时所能得到的快乐。后来，我怀疑自己是否出现了幻觉，我耳畔常常回荡着一种空旷而模糊的声响，我想它不会是侯鸟渐近时悠长的哨子般的翅膀拍击空气的声音，它像是来自一个拥挤的车站，或者一座肃穆的墓地。这声音听上去像是落雪，又像是落沙。 有一天，一个穿橙红（或者棕红色）衣服的女人到我“水边”的寓所里来，她沿着“水边”低浅的石子滩走得很快。我起先把她当作一个过路的人，当她在我寓所前踅身朝我走来时，我终于在正午的阳光下看清了她的清澈的脸。我想，来者或许是一位姑娘呢。她怀里抱着一个大夹子，很像是一个画夹或者镜子之类的东西。直到后来，她解开草绿的帆布，让我仔细端详那个夹子，我才知道果真是一个画夹，而不是镜子。 我的寓所里从未有过任何来访者。她见到我并未遵循两个陌生人相遇应有的程序，而是表现出妻子般的温馨和亲昵。她说她叫棋。她在给我看她的画夹时顺便提了一句现在是秋天了。我的记忆深处痛苦地抽搐了一下，但并未就此而唤醒往事。我为秋天而感到高兴。她站在寓所的门前和我说话，胸脯上像是坠着两个暖袋，里面像是盛满了水或者柠檬汁之类的液体，这两个隔着橙红（棕红）色毛衣的椭圆形的袋子让我感觉到温暖。和棋的初次相遇就使我错过了一次注视候鸟的机会，我想，它们可能在我和棋说话的时候飞走的。我徒劳的目光越过棋的双肩，投视远处“水边”青蓝的水线时，她问了一句：你在看什么？ 那些候鸟…… 她转过身朝“水边”的石子滩望了一眼，又用一种天真而老练的目光看我。 我将棋让进了屋内，接着我们就在两只矮凳上坐下，看她带来的那些画。那些画上也画着一些女人，脸形和身材和棋相似地许就是棋的画像。她有时依在一个电线杆上，远处是一望无际的戈壁滩。有时她穿着夏装斜侧躺在海滨：，也有一些画公园的落叶的。她翘着细长的腿俯卧在覆盖着厚厚叶被的迤逦小径旁。 她在给我看这些画时，两个暖暖的袋子就耷拉在我的手背上，这两个仿佛就要漏下水来的东西让我觉得难受。 这些都是你画的？我说。 不，是一个叫李朴的男孩给我画的。棋说。 李朴？ 是啊，李朴。 我摇了摇头，我说我不仅不认识什么李朴，而且您是谁我一时也想不起来了。恕我冒昧，我接着说，李朴给你赠这些画大概是想和您谈恋爱吧。不过。我又说，我对这些画也一样不感兴趣。 好哇，格非—— 棋陡然坐真了身体，一字一顿地说：李朴你也不认识我你也不认识你难道连李[吉力]也不认识嘛？ 我猛然一惊，我的如灰烬一般的记忆之绳像是被一种奇怪的胶粘接起来，我满腹焦虑地回忆从前，就像在注视着雪白的墙壁寻找两眼的盲点。我隐约记起来了，我和棋说的那个李[吉力]相识那是很久以前的事了，大概是一九八七年…… 不过，你是怎么知道我的名字。 别装蒜了，格非。你离开都市到这个锯木厂旁边的臭水沟来才几年，你的神志竟垮成这样啦，我三个月前曾到你这里来过，你还答应给我看你的小说，还答应过其它一些事。你的记忆全让小说给毁了。 棋说完了这些话，静静垂手而坐，像是等待我沉入往事的梦境，又像是等待我从冥想中挣脱出来。 渐渐地，我眼前的这红色的影像模糊起来，但立即它又重新变得异常清晰。 好吧，我认识你，我说（实际上我想说：我认识你算了）。 棋显出满意的样子，她突然抬手在我脸上皱纹最深的地方抚摸了一下——这是一个仪式，一个我们本来就已相识的仪式，我想大概不会是所谓“情不自禁”。但是我立刻嗅闻到了皮肤相触的一刹那蛋白质释放出来的臭鸡蛋的气味。我觉得这种气味很不错。棋看了我一眼，又将画夹摊在她拢起的双膝上，她在看画的时候不断地注意我的神态，我想她一定是想知道我是否也在看那些画。她从那些画中挑出一张递给我，就是那张画着公园秋天的那幅。 这幅画上是什么？棋问。 一个人的背影 还有什么？ 枯叶子 落叶象征着什么？。 一个人的背影 棋没有再问下去，她说了一句你这个人怎么一点都不懂画就沉默了。过了一会儿，棋又说： 你一点也不像李[吉力] 李[吉力]？ 他不仅懂画而且懂诗懂开密封罐头懂治疗牛皮癣甚至——他还懂不生 不生？ 不生是一种哲学，棋说。 我不懂。 晚上，棋没有离开我的寓所。当然也没有一对男女在一处静僻之所的夜晚可能有的那种事。整个晚上她都在静静地听我说故事，关于我的婚姻的故事。我想棋的聪颖机智使她猜测我在意念深处一定存在着某种障碍或者她宁愿称之为压抑。这是不是我们在看画时才发现的呢？在整个晚上她充当了一个倾听诉说的心理分析医生的角色，这也许不仅出于对我的怜悯，而且我似乎看出来我们都信奉这样一句格言： 回忆就是力量 夜晚，奇异的天象没有出现。“水边”的石子滩变成一种冰莹的纯蓝色。就像化学实验中几种物质产生化学反应后析出的某种蓝色晶体粉末。这些玛瑙似的蓝色石子泛出的冷清的光亮和故事的氛围大相径庭。 后来呢？棋问 后来——我尽量用一种平淡而真实的语调叙述故事，因为我想任何添枝加叶故弄玄虚反而会损害它的纯洁性。 后来，我就在那个卖木梳的老女人身边站住了。 那时正是四月，春天来得很迟。我看见积雪和泥浆冻在一起，高大的城市建筑物挡住了南下的寒流，形成了巨大的风的声音。那些早已废弃不用的商店霓虹灯上挂满了锥状的冰棱。我在企鹅饭店被一个漂亮的女人招引，不知不觉尾随着她走完了半个城市。我想处在我当时那个年龄被一个女人所迷惑是常有的事，但我决定跟着她走一段，仅仅因为我喜欢她走路的姿势。她的栗树色靴子交错斜提膝部微曲双腿棕色——咖啡色裤管的皱褶成沟状圆润的力从臀部下移使皱褶复原腰部浅红色 ——浅黄色的凹陷和胯部成锐角背部石榴红色的墙成板块状向左向右微斜身体处于舞蹈和僵直之间笨拙而又有弹性地起伏颠簸。 我想这样一个在风中行走的女人要在火炉旁烤火或者在浴缸里洗澡不知是怎样一个模样，我还准备往下想下去她突然站住了。我也在那个卖木梳的老女人身旁停了下来。 买木梳吗？ 接下来离奇的事发生了。 我想那个女人毫无缘由地在街道上停下来，是因为我在意念深处产生了一种当时我认为是下流的臆想——譬如裸体之类。不过随之我又认为这个女人停在人行道上是由于她自己遇到了什么事，并非我的意念感应所致。 买木梳吗？ 我在思索该不该买一把木梳，同时又朦胧地感觉到她不久就会回过头来。她果真回过头来。她的目光像是注视着我，又像是留意别处。我回避着她的目光。我知道，心灵感应术曾在这个城市里风靡一时，人们只要在一所称之为“心灵感应中心”的地方训练三个月，就能用意念驱使幻想中的情人来到自己身边。有一些造诣精深的通灵大师还能使意念和星际相通。我心里意识到了一丝隐隐的恐惧感这种恐惧感只有当一个罪犯在明朗的月光下撬锁行窃才会有的。 我又感觉到她马上就会朝我走来。好像她在行动之前她动作的信号就从她身上散发出来穿透冬天凝固的空气，预先告知了我一样。 现在，她正朝我走来。 我看了看岗亭上在冷风中瑟瑟发抖的警察。行人各自走着自己的路，没有注意到我正在遭遇的一幕。 她朝我走来干什么…… 她迎面走来的姿势跟我刚才在她背影中看到的一模一样，她的鬼惑力像泉水一样从她的浅黄色、深棕色、栗树色的衣饰的折褶中流淌出来。我等待着她走近，我的心情一点也不轻松，她双腿轻盈地朝前迈动，我突然有了一种感觉，好像她是静止的，而我正朝她走近。 她在我跟前停下来，朝地面俯下身去。 她在我脚边捡起了一枚亮晶晶的靴钉。 后来呢——棋问。 后来我就再也没有见过她，她捡起靴钉，转身走远，在人流中消失了。 棋审判一样的目光紧盯着我，让我觉得很不舒服。棋说，你有自恋情结。我说大概有吧。棋沉默了片刻，继续说，事情好像还没完。我说，什么事情？ 你和那个女人的事。 我不由得一怔。 那个女人捡起靴钉后，朝一个公共汽车站走去，她上了一辆开往郊区的电车，你没能赶上那趟车，但你叫了一辆出租车尾随她来到郊外她的住所——棋漫不经心地说。 事情确实如棋所说的那样，不过她说错了一个无关紧要的细节：我当时没有足够的钱叫出租车，而是租了一辆自行车来到了郊外。 不过，我说，你是怎么知道事情还没完呢？ 根据爱情公式，棋说。 爱情公式？ 我想事情远未了结并不是棋所说的所谓恋爱公式的推断，它完全依赖于我的叙述规则。我之所以不愿意将这样一个故事和盘托出，是因为我内心深处极其隐秘的角落，想起这件事就让人觉得不痛快，下面我就来讲讲这件事。 我去车铺租自行车的时候，天空已经飘起了鹅毛大雪。雪花在春天的幌子市布下寒流的种子。城市通向郊区的路一会儿就变得非常狭窄了。渐渐我的车轮下露出泥土和煤屎混合的路面。路上行人和车辆渐渐变得稀少，雪花落在上面很快就积成了白白的一片。大路两旁的农舍和绵延的丛林突然出现在眼前。我前面那辆电车开得不快，我的自行车全速追赶，使它不至于从我视野里消失。 电车在郊区站停下后，天已快黑了。我想大概是狂啸的西北风裹着满天大雪使黑夜提前了。她下车后就沿着一条低洼不平的路朝远处亮着忽明忽暗灯光的村舍走去，那个村舍在傍晚的雪中显出一带黑魍魍的影子。这条路不算很窄，但是车轮的印辙和马蹄踏成的圆洞在雪中封冻住了形成一个条条硬深的凹槽，我的自行车轮常常在这些凹槽上打滑，发出挡泥板和车架的黑轶碰撞的铮铮之声。她在距离我约有二十丈远的地方不紧不慢地走着。我们仿佛在路上走了很久，但是在郊外迷茫的雪原上，我很难看到它的尽头。我的自行车链条被坎坷不平的路面震得脱落过几次，但它最后一次脱落时。我的双手已冻得发麻。我不得不花了很多时间才把它重新装好。这一次。当我重新跨上启行车的对候，她的身影已经在远处变得模糊不清了。我狠命地蹬着自行车，它就像是一匹盲马跌跌撞撞地朝前疾奔。 这时，我的前面出现了另一个骑着自行车的人。这个人驮伏在车上显得很小，它也像是在朝前急急赶路。在这样一个寂寥无声的风雪之夜，遇到它让我觉得亲切。它的身影在路面上歪歪斜斜地划着漂亮的弧。在黑夜中，它像是一只黑蝴蝶，或者一只蝙 我的车轮又一次滑到了大路的边缘。大路和田野之间仿佛有一条很深的沟渠，我想这大概是农人为辅设排水管道而挖的。 我的自行车和它相错时，我觉得我右胳膊的袖子和它左边的一只擦了一下，我像是听到了一种轻微的刷子在羽绒布上摩擦发出的声响。 前面那个女人的身影终于又在我眼前出现。在雪夜中我分辨不出她的栗树色的靴子和浅黄色——深棕色的腰部衣饰的皱褶，以及她圆润的臀部成豆瓣状分裂的节奏。她像一滩墨渍在米色的画布上蠕动。我不知道她的住宅是否就在我依稀能看见的灯光闪烁的村子里，我也不知道我究竟会被她带到一个怎样陌生地带。但我似乎有了一种不祥的预感，冬天晚上凛冽的风和远处传来的狗的吠叫使我的呼吸越来越急促。 大约又过了二十分钟左右，她走上了一条窄窄的木桥。这座桥架在很宽的河道上显得很不坚固。我来到桥头的时候，犹豫了一下。因为我没有看到桥面上她刚刚走过去留下的靴印。那些半圆形的靴印在河边突然消失了。我想．也许是大雪将那些靴印遮盖住了——桥面上覆着一层厚厚的积雪。我推着自行车不得不放慢了步子。 深黛色的河流在孤零零的木桥下冥寂地流淌。我竭力在桥上寻找她的影子。 这是一座一边有扶手的本桥。扶手的铁链连接着一些东倒西歪的木桩。像是被毁坏了栅栏的残骸，西北风不断地吹散铁链上的浮雪，铁链在风中发出重金属滑碰的橐橐声响。我有时也偶尔扶一下那铁链，因为桥面没有扶手的一面的边缘已经和桥下的黑影悄悄缝在一起了。夜色已渐渐地深了。远处一直在招引我的村舍的灯火也不知什么时候突然熄灭了。我仿佛置身梦境，从一个很高的冰坡上朝山下滑坠。我似乎感到，那个穿栗树色靴子的女人像是已经到了对岸，但我又觉得她像是仍在我前面不远的桥上——黑夜和风雪将我分隔了。 我的平底胶鞋踩踏积雪在木桥上摩擦着，我的心情不像刚走上桥时那样糟，或许是因为我深信对岸就在不远处，根据桥面微微下斜的弧度判断，它离开我最多不过三四丈远。可就在这时，我站住了。因为我看不清桥面朝前延伸的灰暗的轮廓。我不得不摸索着桥的铁链朝前移动，但是突然我感到桥链也没了。我的脑袋一阵晕眩。我迟疑了一下，回过头。 有一个提着灯笼的人影朝我走过来。那灯光在稠浓的黑暗中像一只毛绒绒的小鸡。 他走近我的时侯，我才看清他手里拎着的是一只马灯。他是一个花白胡须的老人。他在我跟前停下来，他的长须上结满了玻璃碴似的冰棱。 这桥你不能往前走了 为什么 它在二十年前就被一次洪水冲垮了。 老人将马灯抱在怀里，从腰间摸出一支旱烟管，点着了火。在马灯模糊的亮光中，我看见絮絮扬扬的大雪无声地落着。老人猛吸了几口烟。用手指指远处的河面： 那边有一座水泥桥。 我朝老人指向的地方看了一眼，在风中打了个冷战。 刚才有一个女人从这桥上过去了。 没有女人从这过去。 你是谁？ 老人没有答理我，他熟练地将旱烟管别在腰间，将马灯递给我，然后从我手里接过自行车。我们开始往回走。我想他大概是一个看桥人。 我守在桥头劝告每一个黑夜上桥的人不听阻拦的人注定要走到河里去。 可是，刚才有一个女人从这桥上过去了。 我没有看见什么女人过去。 我们已经来到了桥头。我把马灯递给老人。雪花飘落在马灯的玻璃罩上化成水滴滚落。老人说你上车吧，我举着马灯照你一段，他说话的时候，呼出的气柱在空中迅速凝结了，宛如一束手电的光亮。我像是又想起了什么，我对老人说： 你们为什么不把桥拆掉呢？ 还会有更大一次的洪水。 在我跨上自行车的时候，老人又对我说：没有女人从这桥上过去，你可能是在雪夜中看花了眼，雪的光亮会给人造成错觉，而错觉会把人领入深渊。 我就此和老人告别，他在桥头举着马灯，照着那已经封冻的路面。过了一会儿，我身后的灯光消失了，我又重新陷入黑暗之中。 我又想起了那个穿栗树色靴子的女人——我似乎看见她上了那座木桥。她现在在哪里？那个老人是谁？那究竟是一座怎样的桥？也许等天晴了，我该重新到桥边来看看。我正想着，自行车又开始猛烈地跳动起来。我记起了这段路面。这路面被车轮和马蹄压轧成一道道深深的凹槽，车轮在上边不断打滑。我还记起了那个骑自行车的人，我的耳畔又响起了我和它袖子相擦的那种刷子在羽绒布上划出声音。想起那个像蝴蝶一般歪歪斜斜的骑车人，我的心情变得轻松了一些，因为我能够通过它把自己和现实联接起来，我担心自己是否丧失了理智，而处在一个桥边老人所谓的雪夜错觉之中。 我的自行车更加剧烈地颤动了一下，车轮像是碰到了一个硬物上，我差一点从自行车上摔下来，我的好奇心和探究心理使我停下车来，想看看那个硬物是什么。 那是一辆歪倒在路边的自行车。 接下来我看到的事情或许棋早已猜到了。她在我“水边”寓所的椅子上不安分地躁动着。她一会儿拿起她的画夹，一会儿哼哼卿卿地看着天花板，对我的故事显示极度的不满。 这是一个非常庸俗的结尾。棋说。 你在路边发现了那辆自行车你马上意识到了是你刚才在追赶那个穿栗树色靴子的女人时匆忙之中将它撞倒的你开始四处寻找它的人影最后你在路边那个埋排水管道的沟渠里发现它的尸体尸体已冻得僵硬它的脸上落满了雪花。 是这样。 我开始陷入了沉默之中。棋也呆呆地托着下巴，凝视着“水边”青蓝色的石子滩。现在夜色正潮。“水边”的凉气沿着远处水面朝公寓斜升的坡道，悄悄越过窗格爬进室内，我感到一阵微微的凉意。我打了一个长长的呵欠，棋在沉思中黑眼珠朝我突然翻动了一下，含糊不清地说：你困倦了？我说没有。我想在夜阑人静的时候，面对一个姑娘独坐，大概不大适宜提出诸如睡觉之类的要求。我想我们都已忘记了时间，也许在天亮之前我们会一直这样默坐下去。我试着找出一些无关紧要的话题来润滑一下现在多少变得有点尴尬的气氛。我觉得我的大脑像是一个空空落落的器皿，里面塞满了稻草和刨灰。就在这个时候，我想到了棋在我和初见时谈到的那个李[吉力]。 你是怎么认识李[吉力]的？我说。 棋的脸上慢慢地浮现出一层红晕。她似乎立刻沉浸在幸福的回忆之中。她潮湿的眼睫毛参差错落像一排芦苇的篱掩住了黑白的眼球。她用妻子般空旷而充满诗意的语调告诉我：她先认识那个叫李朴的男孩。 李朴是谁？我问。 李[吉力]的儿子。 我思索着这个被棋称作“李朴”的男孩在我记忆中的印象。我记得在一九八七年，我在李[吉力]的乡间别墅作客，我们隔着会客厅透亮的玻璃看见后花园的雪地上，一个男孩正在滚雪球。我想那个玩雪的小男孩会不会就是棋所说的李朴？ 棋的目光仍注视着窗外。她的双眸熠熠发亮，像是要沁出白色或黑色的水汁。我想所有的女人沉入对恋人的回忆和想象之中大概都是这么一副自命不凡的神态。对于女人来说，生活有时就是想象。 我真的感到困倦了。我点燃了一支烟，但它并未使我清醒。我倚着公寓白色的墙壁昏昏欲睡。“水边”的夜晚静极了。微风轻轻吹拂着窗帘，潮水有节奏地漫过石子滩。我在混沌而沉重的睡意之中，仿佛听到棋在呼唤我的名字，她的童音未脱的呼唤像是从一个遥远的地方传过来。她的衣服在椅子上摩擦发出之声。棋像是又处在焦灼不安之中，她的飘忽不定的影子在我眼前不断地徘徊。我渐渐坠入梦乡。 时间过去了很久。棋轻轻地将我推醒。 那个女人—— 什么女人？ 那个穿栗树色靴子的女人—— 怎么？ 你后来再也没有没有见过她吗？ 天还没有亮。棋蓬松着长发站在我对面。有一些汗粒顺着她的发梢慢慢滴落。我听到棋的呼吸声很重。我想她大概已经被故事的那些悬念和细节织成的网罩住了。她对故事的过于敏感使我注定要谈到以下所叙述的这些事。这些事离我很久很远了，但是当我每次重温许多年前的阳光和空气，我仿佛觉得伸手就可触摸到它。我无法不回忆往事。即使在这样一个平常而宁静的夜晚棋不向我提起它，“水边”的那些候鸟也会叠映出它们清晰的影子。我在决定如何向棋叙述那些事时，颇费了一点踌躇。因为它不仅涉及到我本人，也涉及到我在“水边”正在写作中的那部书，以及许多年以前，我的死于脑溢血的妻子。 我和那个穿栗树色靴子女人的重逢是一次意外的巧合。一九九二年春天，我因《黑鸭》出版社之约来到郊外修改一个长篇小说。我住在歌谣湖畔的一幢白色小楼里。这幢新建的小楼没有人住，因为自来水管道还未辅设，房间的设施很不完备，楼前的花园还是一片荒芜。小楼竣工后多余的一些建筑木料和钢筋混凝土的果柱被横七竖八地搁在楼房的四周，让人觉得有些压抑。我来到这里之前，《黑鸭）出版社的几个董事副董事把我的右手握得又疼又酸；很抱歉条件很差连撒尿的抽水马桶还没有运去格非你看着办吧。 我的卧室朝南有一个很大的阳台。现在正是早春时节，太阳在午后照临阳台时，我就在那儿抽烟憩息。远处歌谣湖浩翰的水面上空，白色的云块很低很厚，静静地悬挂着，湖水由于酸雨和城市排泄的废气和残渣已变得污浊不堪，湖面边缘的沼泽上绵延的原始森林蒙上了一层灰黄的颜色。有几只白鹤和鹭鸶贴水面盘旋而过。每天黄昏的时候，我总看见几个园丁在那片花园里忙碌着，他们将长在荒地上的荆棘和杂草拔掉，然后在上面栽金盏花和鸢尾。我有时也来到花园和那些园丁聊天。这些如土地一般沉默的老人回答我的问话时显得非常吃力。对于农事和天气他们并不像我那样感兴趣。我一有空就到花园里帮助他们编织花圃的竹篱，给金钟和鸢尾花浇水。当花园里到处都盛开着灿烂的金盏花和鸢尾时，我的小说快要完稿了，我在歌谣湖的这段日子里，时间悄无声息地过去了，这个远离城市噪音的地带给了我安定的心绪和美妙的感觉，但是不久以后发生的一些事却使这幢白楼在我的心中留下了灰暗而并不愉快的记忆。 这天下午，我像往常一样来到歌谣湖边散步。湖边枯黄的草地正在抽出新芽。那些新翻的泥土像波浪一样在广阔的田野上匍匐着。 我觉得我已经走了很远。我回望波光斑澜的湖面，那幢傍水而筑的小白楼已看不见了。温暖的阳光中裹夹了一丝北风，这些风像清晨还未完全褪尽的夜色，让我觉得有点冷。我脚下的地上渐渐出现了一些米黄色、灰白色的鸟粪。我在一只正在湖边饮水的山羊旁停住了脚步，因为在这时，我听到了一缕很不清晰的哭叫声。我四下里张望了一会儿，宽阔而高远的田野上不见一个人影。我点燃了一支烟继续往前走，不久我就看见在一片微斜的坡地上，一个高大的男人和一个女人滚在一起。他们沿着山坡往下滚，女人的茶绿色的头巾脱落在坡地上，她的长发飘散开粘满了草屑和泥土。 当我憋足了劲冲到他们身边时，那个男人已经把女人松开了。那个女人俯卧在地上，轻轻地啜泣着。我走到那个男人面前，正想揪住他的衣领问个明白，没想到他先给我的膝盖来了一脚，我倒在地上趴了三分钟。我昏昏沉沉地从地上爬起来，那个男人已经走上了那个斜坡。女人的脸上几排牙印还在不断地往外渗血。她整好了衣扣，跌跌撞撞地从我身边捡起了那茶绿色的头巾。她朝我歉意地笑了笑： 那是我男人。． 我的脑壳“咯噔”一下，像是关节错位的榫头弥合了一样，我突然发现她就是我早些年在企饭店鹅饭店碰到的那个女人，我的眼前 我的眼前一边又一边地重现她刚才俯身捡头巾的动作，它仿佛和我早已在眼帘的屏幕上成为定格的检靴钉的姿势叠合了。这个女人我觉得已全力将她忘记。今天她突然出现在我的眼前，使我感到胸脯一阵阵抽搐。她扑闪着泪花看着我，她也像是觉得我有些面熟，异样的目光中透出疑问和猜忌。 我看了看那个已经走远的男人，又看了看她。 刚才你干嘛哭叫？我问。 他——，女人显得有些语塞，她的脸涨得彤红。 他刚才把我弄疼了。 女人将头巾搭在头上，匆匆追赶她的丈夫去了。我走了那道斜坡。我看见那个高大的男人步履蹒珊地在田野上走着，他的腿脚看起来不太灵便。果真，他一会儿就在面前的一条闪亮的沟渠里跌倒了。女人朝前跑了几步，又远远地回过头来朝我叫了一声： 他是个瘸子—— 瘸子？我苦笑了一下；他刚才在我膝盖上那一脚倒是踢得很卖力。 我手里玩捏着一枚镍币，沿湖边颓然若失地往回走。那个女人已经跑到男人身边。他们的身影在我的眼前越来越小了。在我们之间，潮湿的风在一望无垠的田野上吹着，我看着他们消失的方向——西斜的太阳暗红色的光照亮了那片密密的白烨林和村舍白色的屋顶。我想他们也许就住在离我的小白楼不远的村子里。 以后的几天，我再也没有在这一带的田畴上看见他们。每天午后，我的影子伴随我来到离白楼很远的这片坡地上，我等待着那个女人到田野里来耕作。麦子已经长得很高了，几场大雨浇过，田野里到处都是绿色植物的清香，成群的蜜蜂飞过来预示着气候日渐温暖。但是那个女人的身影一直没有出现。 《黑鸭》出版社的一位常务编辑来到歌谣湖畔看我，我告诉他，我的稿子只完成了一半。我想在我没有重新见到那个女人之前，我不打算离开这儿。 我在小白楼渐渐觉得孤寂无聊。一天，一个老园丁答应带我去白楼附近的村子里去喝酒。我们在狭窄的田垅上一前一后地走着。我在路上向老人打听村子里的情况，同时我请他回忆一下村里是否有一个常穿栗树色靴的女人？老人说村里的女人很多，但是他不知道她们穿什么颜色的靴子。 那个酒店就在村口。我吮吸着晚风中浓浓的酒气走进了酒店院门的木栅栏。栅栏旁有一个腰间围着泥黄色裙布的人正从一口大缸里往外掏酒糟。酒店墙上原先像是涂抹着一排深红色的大字，这些字迹经过长年的风吹日晒已经变得难以辨认了。我几乎是挑起门帘走进酒店的同时就看到了坐在墙角的那个瘸于。他似乎已经喝醉了。 酒店里昏暗的灯光被劣质烟草的雾气笼罩着，潮湿的地面散发出一阵腐烂霉饼的气味。我要了一瓶洋河大曲，挨着离酒柜最近的一张桌子坐了下来。酒店里没有什么人，柜台上那个店主模样的老人手里握着两个咔咔作响的钢球正在打盹。 瘸子在墙角独自喝着酒。他的背像是有点驼。黧黑的脸上刻着衰老的沟纹。他的胡须卷曲着，沾满了晶莹的酒滴。他高大的身躯稳稳地坐着，像是永远在聆听着什么，只是当他伸出手在桌面上摸索酒瓶时，我才看到他被烟熏得焦黄的手指有些颤抖。 那个女人来到酒店的时候，我一点也没有察觉。当一些类似于酒瓶或酒杯之类的玻璃器皿砸在地上，发出很响的破碎之声我才在朦胧的醉意中看见那个女人正在把已瘫倒在桌下的瘸子扶起来。瘸子踉踉跄跄靠着桌沿站起来，将脸凑近那个女人，朝她脸上啐了一口痰。女人刚想摘下头巾擦去痰迹，我看见瘸子的手在她眼前挥动了一下，那个女人就在酒店潮湿的地面摔倒了。女人像一滩墨渍一样卧在反射出酒店暗绿色灯光的地上。她软软腰肢扭动了一下双手撑着地面，浑身的筋络像杯子里盛满的水一样晃浮着。这时，我已经走到她身边，我拽起她的一只手把她搀起来，那个男人已伏倒在桌上睡着了。女人的脖子上被手指抓破的细长的血印像一条美丽的蜈松。女人用手指拢了一下湿漉漉的发尖，走到桌边拉了拉那个男人，同时她哀怜的目光朝我瞥了一眼，我走过去将男人背起来，女人从地上捡起那个瘸子脱落的一只胶鞋，我们就走出了酒店。店主手里仍然在捏玩着两个亮晶晶的钢球在打盹，有一缕稠浓的口涎在他嘴角挂着。我们走到院子里的木栅栏门边一个黑影依旧在一只巨大的缸里往外掏酒糟。我仿佛感到这个酒店里的时间是静止的。 在路上，那个女人没有说话。漆黑的夜里有只狗在村头狺狺地叫着。 她的家不像我想象的那样邋遢。我在路上一直被背上的男人喷着的酒气呛得想吐，当我在她卧室明亮的窗前坐下后，女人已将丈夫在床上安顿好了。女人朝我招招手，我们来到外间的一个很小的客室。她为我沏了一杯茶。我手抚茶杯的边沿，转动着它，女人在我对面坐下来，双手合抱在胸前痴呆地看着茶几的桌面。这时我站起来，女人也跟着站起来：你喝杯茶再走。我说我想再到你卧室里看一眼。女人先是迟疑了一下，随后就说：好吧。我们又回到她的卧室。我看见她的床前整齐地放着一双擦得油光锃亮的栗树色靴子：她的栗树色靴子交错斜提膝部微曲双腿棕色——咖啡色裤管的皱褶成沟状圆润的力从臀部下移使皱褶复原腰部浅红色——浅黄色的凹陷和膝部成锐角背部石榴红色的墙成板块状向左向右微斜身体处于舞蹈和僵直之间笨拙而又有弹性地起伏颠簸。我的眼睛眨闪了几下从卧室出来。女人说你有什么东西丢了吗？我说没有。我们重新在客室里坐下。我想从企鹅饭店和这个女人偶尔相遇，至今已有许多年，重新浇灌这棵在我记忆中已枯死的青春之树显然已经没有太大的意义。我正视着面前这个女人清澈的眼波，嘴里隐隐有了一种酸涩的咸味。我点燃了一支烟，又递给她一支。她重重地吸了一口，眼角变得有些潮湿。腾起的烟雾在日光灯管上切割缭绕，灯管发出咝咝的声音。 烟草的香味使我在浓浓的酒意中感到异常清醒，我的脸有些烫。女人抽烟的姿势很好看，她夹着烟卷的白晰的手在我眼前晃动着。我们听到了里屋男人悠长的鼾声。 我第一次看到你是在七、八年前。我说。 七、八年前？ 我在企鹅饭店的门外遇见你。 企鹅饭店？ 后来我跟着你来到大街上。 什么大街？ 后来你在一个卖木梳的老人前面站住了。 卖木梳的老人？ 你在我脚边的街道上捡起了一枚靴钉。 靴钉？ 你随后上了一辆开往郊区的电车。 你说什么？ 那天雪下得很大，我租了一辆自行车追赶那电车。 我不明白。 你下车后天已经黑了。 你喝醉了。 后来你上了一座木桥就消失了。 你喝醉了。 你喝醉了。——女人温存地对我说：在我们这儿没有什么企鹅饭店，没有大街，也没有卖木梳的老人。你喝醉了，要不你是记错人了？ 我说我是在城里遇见你的。 女人笑了一下，她伸手端起我面前的茶杯呷了一口茶将茶叶末轻轻吐掉： 我从十岁起就没有去过城里。 夜已经很深了。我呆呆地凝视天花板。那个雪夜我尾随那个女人来到郊外的种种细节又一次清晰地呈现在我眼前，我看了看面前的这个美丽的女人，她诚挚而坦然，脸上浮现出乡村纯朴的妇女特有的腼腆。她站起来给我的茶杯倒满了水，然后问我是不是觉得冷，要不要关窗。我说不用了。 那么，我说，你们这儿是不是有一座倒塌的木桥。 通往城里的方向是有一座断桥。 是洪水冲垮的吧？ 不，是给人偷拆了木料。 女人像是突然想起了什么，她告诉我这样一件事：有一天夜里，雪下得很大，我男人从邻村喝酒回来曾路过那座木桥。他提着马灯走到桥头，他看见木桥上有一些胶鞋的鞋印和自行车车轮的胎辙。他举起马灯朝桥上晃了晃，看不见人影。他看见桥一侧的铁索链上积满了雪，有些地方显露出手抓过的痕迹。桥面上的那些鞋印和胎辙还没有完全被大雪遮盖。他想也许有人推着自行车刚刚从这断桥上过去。但那天他喝得醉熏熏的，另外他的腿脚也不灵便就没有上桥去看看。第二天雪晴了，人们从河里捞起了一辆自行车和一个年轻人的尸体。 女人打着呵欠说完了这件事。 我说我该走了。 女人没有吱声。她的沉默似乎是她有意挽留我的一种隐晦的方式，我想。我坐着没动。 你住在哪儿？女人问。 我告诉她那幢白楼。 女人像是知道那幢楼。女人说夜已经很深了，春天麦子和油菜都长高了，有一些狼夜里常在荒野上转悠要不就明天早上走吧。 我们就在客室里坐到天亮。 “水边”的夜幕悄悄隐去了。天亮的时候我和棋都没有察觉。现在阳光穿透公寓的玻璃窗投射到棋橙红色的衣服上。在早晨清晰而温暖的光线中，我看见棋的脸有些憔悴。我问她是不是饿了？要不要喝杯咖啡？棋点点头。我从厨房给她弄来了咖啡，棋似乎仍在想着我的故事。 你和那个女人一直坐到天亮？棋用塑料小勺在杯中轻轻搅动着，问我。 是这样。我说。 你那天是不是有些醉了？ 是的。 你没有碰那个女人？棋诡秘地微笑着。 黎明的时候天有些凉，她给我披上了她男人的大衣，我在浑浑噩噩中抓住了她的手，但她马上把手抽了回去，像一些水从我指缝中流走了一样。 我坦白地对棋说。 我发觉你的故事有些特别。棋说。 怎么？ 你的故事始终是一个圆圈，它在展开情节的同时，也意味着重复。只要你高兴，你就可以永远讲下去。不过，你还是接着讲下去吧。 我呷了一口咖啡，继续对棋描述以后发生的事。 一天深夜，歌谣湖一带突然下起了瓢泼大雨，雨下到第二天早晨还没有停。我拥着薄薄的棉被坐在床上吸烟。现在梅雨季节来临了。我看是绿色的田野上空，雨幕像密密的珠帘一样悬挂着。大风将白楼的木栅栏院门刮得砰砰直响。我谛听着大雨中的各种声响，又渐渐入眠了。到了晌午的时候，我恍惚听到楼下有人在砸门。我想那大概是白楼花园里的园丁。可是下着这么大的雨，园丁来干吗？砸门声越来越响。我懒洋洋地披上衣服下楼开门。我轻轻地拨开门闩，大风扑面直灌进屋来。我一连打了好几个冷战。 那个女人站在雨中。 她的衣服已被雨水淋得透湿。她披肩长发上不断地有一些晶亮的水滴滚落下来。她告诉我，她的男人死了。 我披了一件雨衣就跟着她走出了白楼。 大雨模糊了村子的轮廓。我们在狭窄泥泞的田埂上朝片影影绰绰的村舍跑去。女人由于焦急和慌乱，在路上摔倒了几次，使得我们的速度反而慢了下来。女人说，她的丈夫昨夜又去了那家小酒店，晚上回来时跌倒在村中的一个粪池旁。第二天早上，两个清理阴沟排水的老人发现他的尸体。他的脸已被雨水浇得煞白，耳朵里灌满了大粪。我拽住女人的手——她的小手像鳗鱼一样冰凉，我的思绪像是给大雨搅乱了。眼前一片空白。 当我们来到村头的时候，我看见有几个中年人拢着袖管，抱着扎有红布绸的铁锹往田野里走。女人啜泣着轻轻地说，他们要去墓地挖坑穴。 女人的院子显得依旧清朗。大雨把黄泥地面冲刷得又硬又平，地上有一些稀稀落落的鞋印。有一个木匠模样的人正在盛开的木榛花丛弯锯着一段木料。屋子里传来叮叮当当钉棺材的声音。 那个男人躺在一扇破旧的门板上。他的身体已被几个年老的妇女收拾干净了。他穿着硬挺的哗叽制服，刮净了胡须的脸上显得清癯而红润。尸体旁那些钉棺材的人像是完全沉浸在熟练的操作中，榔头敲在腐蚀的木板上，松计一样的木屑由于振荡而不断地跳动着。一个巫婆模样的女人走到尸体旁，双膝跪下，她高高地举起了双手，正准备哭叫，她突然想起了什么，灰白的眼珠朝我翻动了一下：钉子还不够。我去院子里木匠身旁找来了钉子，巫婆又看了我一眼：再去找些绳子来，我刚一转身，巫婆高举着双手往地上一拍，伤心地哭了起来。 我去房里找绳子时，那个女人紧紧地跟着我，她哆嗦的身体和我贴得很紧。 尸体入敛的时候，呼啸了一夜的大风突然停了，雨还在渐渐沥沥地下着。屋子里静寂无声，女人伏在棺材的边沿，久久地望着她男人的尸体。她的哭声感染了室内尘封的空气。钉棺材的几个男人把榔头扔在地上，拍了拍手里的灰尘，蹲在一旁吸烟。 时间过去了很久。 女人的嗓音显得有些暗哑了。我看见她一边哭泣着，一边骨碌碌翻动着清亮的眼球朝四周察看，一片蜘蛛网像胸环靶一样悬挂在梁下，青绿色的蜘蛛攀援在一根细长的丝线上，像钟的下摆在微风中晃动。我忽然意识到这个女人的悲伤也许是装出来的。又过了一会儿，木匠冲着我做了一个手势，我们抬起那块像隧道的穹顶般的棺盖，将它轻轻盖在棺木上。巫婆过来把那个女人扶开了。在盖棺的一瞬间——那几个钉格的男人朝棺木围过来，准备将它钉死，我突然看见棺内的尸体动了一下。我相信没有看错，如果说死者的脸上肌肉抽搐一下或者膝盖颤抖什么的，那也许是由于人们常说的什么神经反应。但是，我真切地看见那个尸体抬起右手解开了上衣领口的一个扣子——他穿着硬挺的哔叽制服也许觉得太熟了。 我没有吱声。 送葬后的当天，我没有离开那个女人的屋子。女人对我说，她一个人在晚上的时候会感到害怕。她让我至少陪她三天。 第三天晚上，梅雨连绵。 女人坐在我对面，她的眼圈微微泛红。我们之间的冗长的话题已经在前两个晚上谈完了。我觉得在喋喋不休的对话中，时间流逝得很快。而面对沉默，我们的心力都显得非常脆弱，我还在想着那个男人的死。他的死多少有些蹊跷，有时我觉得这也许是一个阴谋。 你的男人醉死，你怎么想起去白楼找我？我说。 不知道。 他深夜未归，你为什么不去酒店看看？ 别去提它了—— 女人妩媚地对我笑了笑。我觉得她笑得有些勉强。但我的内心还是悸动了一下，她摊开双手平放在桌面上，我迟疑了一阵，我手心朝下，轻轻地滑向她的柔润的手腕。接下来我们俩做的事不便详尽描绘，但有一些和那种事本身并无太大关联的枝节，如下所述，权且当作这个故事的结尾。 窗外雨声越来越大。女人叹息般的目光久久地注视着我，她俯下身帮我解鞋带的时候，天空炸过一串闷雷。我的腿一阵抽搐。女人抬头看了看我，又低下头去解鞋带。我们俩在床上躺下来，由于连日梅雨，我觉得棉被有些潮湿。我在无意中碰到她青蛙皮一样冰凉的皮肤，闻到了散落在她发中樟脑丸的气息。我木然地凝视着帐顶，好久没动。 我宁神屏息谛听室外风雨。 你在想什么？女人说。 屋外像是有一种奇怪的声音。 什么声音？ 一个女人在哭泣。我说。 那是大风溜过树梢的声响。 不，是有人在哭。 什么地方？ 院子里。 女人和我翻身下床。我裹了一条毛毯，趿着鞋子推开房门来到院子里。院子里什么也看不见。那个女人按亮了手电筒。随着那条惨白的光柱的缓缓移动，我看见了废旧的鸡埘，在大风中摇曳的木榛花树，和泛着污移黑水的墙根阴沟。 大概是一只猫——女人说。她把我拉进屋内，关上了门。 我们重新在床上躺下。女人伸手拉灭了电灯。过不多久，那哭声又出现了，它像是来自一个死神笼罩的病榻，又仿佛从更加遥远的河面上传来。那哭声稚音未脱，时隐时现，我觉得我的头颅在这种弱节拍的声音中正逐渐膨胀。 我第二次下床的时候，女人躺着没动。 我拉开通向院落的大门。一道耀眼的闪电在天空中无声地出现，远处墨绿色的田畴和宽广的湖面一下被闪电照亮了。 在闪电出现的一刹那间，我看见一个少女站在院子的当中，她赤裸的身体在地面上的水洼中形成了清晰的倒影。她婴儿一样的脸上挂满了泪珠。 我的记忆似一条锈蚀的铁链如灰烬般寸寸断落。在记忆消失的瞬间，我脑子里浮现出在我六岁时，看着我的妹妹在澡盆里洗澡的画面，同时我的耳边又回荡起那个如梦的夜雪，我在那段四槽封冻的路面上曾听到的羽绒布摩擦而发出的微弱声响。剩下的什么不都知道了。我扶着门框的手无力地滑落——我在门边晕倒了。 我醒过来的时候，那个女人守护在我的床前。她如母亲一般深沉而温暖的目光正注视着我。她静静地吸着烟，朝我嫣然一笑。我也要了一支烟点上，浓郁的烟味使我慢慢镇定起来。 你刚才看到什么—— 我把我看到的全对她说了。 你的胆子比我还小，那都是你的幻觉，你累了。女人说。 我说在我刚才昏睡的时候，做了一个奇怪的梦。什么梦？女人问。我梦见你的尸体飘浮在那断桥下的河面上，你的乳房上长满了青草。桥头有人在唱着《玫瑰，玫瑰处处开》。 女人苦笑了一下。 我们结婚吧？我说。 好吧。 后来你就跟那个女人结婚了？棋长长地舒了一口气。 是的。 现在“水边”一带正是中午时分。炽烈阳光将退潮后棕红色的石子滩晒得灰白。棋追问着我和那个女人结婚以后的情况，我说在结婚的当天她就死了。结婚的日子是按她的意愿选定的，那天是她三十岁的生日。我们在甜静安详的烛光中喝着葡萄酒，她突然一连说几声“灯灭了”，脑溢血模糊了她的视钱，我眼看着她红润的脸色转为蜡黄，但我知道，已不可救。 棋从我公寓的椅子上站了起来，她一定是知道我的故事再也没有任何延伸的余地了。她说她该走了。她还说今天下午她要去“城市公园”参加一个大型未来派雕塑的揭幕仪式。她说这座雕塑是李朴和一些自称为“慧星群体”的年轻艺术家共同完成的，她说过一些时候再到“水边”的公寓里来看我。 棋在跟我临别的时候，我觉得她跟来时一样陌生。她抱着那个帆布裹着的画册，匆匆离开我“水边”的公寓，没有说再见。 我仍然在写那部圣约翰预言式的书。“水边”一带像往常一样寂静。那些“水边”的鹅卵石，密密麻麻地斜铺在浅浅的沙滩上，白天它们像肉红色的蛋，到了晚上则变成青蓝色。棋曾经别有用心地把“水边”称为锯木厂旁边的臭水沟，我一度被她的话所困扰。有一次，我沿着“水边”枯白的茅穗绵延的水线，朝北走了整整一天，没有发现什么据木厂。回到公寓的时候。已经是深夜了。黑洞洞的天空中又出现了那拖着亮晶晶尾巴旋转的星辰和成不规则樱桃形的月亮。时间像是过去了很久。棋一直没有到公寓里来。我每天坐在公寓的窗口，看着那夜霜化成的水滴从高高的屋沿下坠落。 我天天期待着棋的出现。 不知过去了几个寒暑春秋。有一天，我终于看见棋沿着水边浅浅的石子滩朝我的公寓走来。她依旧穿着橙红色（或者棕红色）的罩衫，脚步在乱石中踩出空落的声响，她耸起的双乳不驯服地窜动着。她怀里抱着那方裹着帆布的画夹，而远远地看起来，那更像一面镜子，我坐在公寓的门前，等待着棋朝我走近。 棋走到正对我公寓大门的路口，突然停住了。她看了看明净宽阔的水面，又转过身来看了看我。我想，她大概是示意我过去。我走到棋的身边。 有水吗？棋说。 在晌午的阳光中，她一定是走渴了，我给她弄来水。她仰起脖子喝完了水，抹了抹嘴唇，将杯子递给我。 你又给我看画儿来了吗？我说。 什么？！ 她像是没有听清楚我的话，漠然地看了我一眼。 那大概是李朴为你新画的吧。我说。 什么李朴？棋说。 李[吉力]的儿子—— 棋无可奈何地笑了一下，她说我不认识什么李朴、李[吉力]，而且也从来没人给我画过画——您是谁？ 棋——，我说，前一段时间你不是到我的公寓里来过吗？你让我看了你说是李朴的画，那些画上画了一些落叶和电线杆，我们在夜晚说着故事，通宵未眠—— 我竭力搜寻记忆中那次和棋的初逢的每一个细节。然而棋固执而有礼貌地打断了我的话。 我的名字不叫棋，我是一个过路人，天热了，我跟您讨杯水喝，您一定是记错人了。 那么——我指指她怀里抱着的画夹。 少女将那个帆布包裹搁在膝盖上，熟练地解开青绿色的带子。 那是一面锃亮的镜子。 少女将镜子重新包好，夹在怀里，她捋了捋披散的长发，朝我摆了摆手，转身走了。 少女的身影离我远去了。 褐色的鸟群扑闪着羽翅，掠过“水边”银白钢蓝色的天空，在看不到边际的棕红沙滩上布下如歌的哨音。这些褐色的候鸟天天飞过“水边”的公寓，但它们从不停留。]]></content>
  </entry>
  <entry>
    <title><![CDATA[会跳舞的树]]></title>
    <url>%2F2017%2F09%2F24%2F%E4%BC%9A%E8%B7%B3%E8%88%9E%E7%9A%84%E6%A0%91%2F</url>
    <content type="text"><![CDATA[Dancing Tree .trunk, .trunk div { background: #136086; /*border-radius:$w;*/ width: 100px; height: 10px; position: absolute; left:50%; top:70%; margin-left: -10px; -webkit-animation-name: rot; animation-name: rot; -webkit-animation-duration: 2.02s; animation-duration: 2.02s; -webkit-animation-iteration-count: infinite; animation-iteration-count: infinite; -webkit-animation-direction: alternate; animation-direction: alternate; -webkit-transform-origin: 5px 5px; -ms-transform-origin: 5px 5px; transform-origin: 5px 5px; -webkit-animation-timing-function: ease-in-out; animation-timing-function: ease-in-out; } .trunk.trunk, .trunk div.trunk { bottom: 0; left: 50%; -webkit-animation-name: rot-root; animation-name: rot-root; -webkit-animation-duration: 2.5s; animation-duration: 2.5s; } .trunk > div, .trunk div > div { /*opacity:0.9;*/ top: 0; left: 100px; -webkit-animation-duration: calc(inherit / 2); animation-duration: calc(inherit / 2); /* don't works */ } .trunk > div:nth-child(2), .trunk div > div:nth-child(2) { /*animation-duration:15s;*/ -webkit-animation-name: rot-inv; animation-name: rot-inv; -webkit-animation-duration: 1.7s; animation-duration: 1.7s; } @-webkit-keyframes rot { from { -webkit-transform: rotate(15deg) scale(0.72); transform: rotate(15deg) scale(0.72); } to { -webkit-transform: rotate(45deg) scale(0.72); transform: rotate(45deg) scale(0.72); } } @keyframes rot { from { -webkit-transform: rotate(15deg) scale(0.72); transform: rotate(15deg) scale(0.72); } to { -webkit-transform: rotate(45deg) scale(0.72); transform: rotate(45deg) scale(0.72); } } @-webkit-keyframes rot-inv { from { -webkit-transform: rotate(-45deg) scale(0.72); transform: rotate(-45deg) scale(0.72); } to { -webkit-transform: rotate(-15deg) scale(0.72); transform: rotate(-15deg) scale(0.72); } } @keyframes rot-inv { from { -webkit-transform: rotate(-45deg) scale(0.72); transform: rotate(-45deg) scale(0.72); } to { -webkit-transform: rotate(-15deg) scale(0.72); transform: rotate(-15deg) scale(0.72); } } @-webkit-keyframes rot-root { from { -webkit-transform: rotate(-95deg); transform: rotate(-95deg); } to { -webkit-transform: rotate(-85deg); transform: rotate(-85deg); } } @keyframes rot-root { from { -webkit-transform: rotate(-95deg); transform: rotate(-95deg); } to { -webkit-transform: rotate(-85deg); transform: rotate(-85deg); } }]]></content>
  </entry>
  <entry>
    <title><![CDATA[秘密花园]]></title>
    <url>%2F2017%2F09%2F21%2F%E7%A7%98%E5%AF%86%E8%8A%B1%E5%9B%AD%2F</url>
    <content type="text"><![CDATA[链接: https://pan.baidu.com/s/1kV7mhH9 密码: amt1]]></content>
  </entry>
  <entry>
    <title><![CDATA[vc++(vs2010) windows编程与绘图程序设计]]></title>
    <url>%2F2017%2F09%2F21%2Fvc%2B%2B(vs2010)%20windows%E7%BC%96%E7%A8%8B%E4%B8%8E%E7%BB%98%E5%9B%BE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[11 Vc++2010开发平台概述 31.1 Vc++2010概述 31.2 Visual Studio 2010 集成开发环境 31.2.1安装Visual Studio 2010 31.2.2配置Visual Studio 2010 31.2.3解决方案和项目 31.2.4生成和调试工具 31.2.5部署工具 31.2.6 Ribbon界面设计可视化 42 Visual Studio 2010 MFC基本程序设计 42.1 MFC应用程序概述 42.1.1简单的MFC应用程序 42.1.2 MFC应用程序分析 42.2 MFC应用程序的创建 42.2.1 用AppWizard创建CLR控制台应用程序 42.2.2 用AppWizard创建win32控制台应用程序 42.2.3 用AppWizard创建一个MFC应用程序 52.3 MFC的类 92.3.1 MFC应用程序中包含的类 92.3.2 应用程序类 102.3.3 主框架类 102.3.4 视图类 102.3.5 文档类 102.3.6 对话框类 102.3.7 菜单类 102.3.8 线程基类 103 Wndows窗体应用程序 113.1 创建Wndows窗体应用程序 113.2 窗体属性及设置 123.3 窗体事件及处理 133.4 窗体控件添加与编辑 134 用户界面设计 134.1 菜单设计 134.1.1 菜单的类型 134.1.2 菜单设计 134.1.3 创建弹出式菜单 204.1.4 创建动态菜单 204.1.5 创建基于对话框的菜单 204.2 工具栏设计 204.3 状态栏设计 205 对话框设计 205.1 静态对话框 205.1.1静态对话框的建立过程 205.1.2静态对话框的应用 215.2 非静态对话框 315.3 通用对话框 316常用控件 316.1 公共控件 316.2 容器 316.3 数据控件 317 键盘鼠标事件 327.1键盘事件 327.2 鼠标事件 427.2.1客户区鼠标消息 427.2.2非客户区鼠标消息 457.2.3实例 468 图形文本与图像处理 518.1图形设备接口GDI（Graphics Device Interface） 518.2 设备上下文DC（device context） 548.2.1 设备上下文概述 548.2.2 CDC类 578.3 绘图环境 608.3.1绘图环境介绍 608.3.2映射模式与坐标系 618.3.3绘图颜色 718.3.4设置绘图属性 728.3.6几何对象的结构和类 798.4 画笔和画刷 858.4.1画笔 858.4.2画刷 928.5 绘图 998.5.1 绘图步骤 998.5.2 画像素点 998.5.3 画线状图 1008.5.4 拖放画动态直线 1048.5.5 画填充图 1098.5.6 清屏 1118.5.7 在控件上绘图 1128.6 文本绘制 1158.7 位图 1158.8 图标和光标 1168.9 图像处理 1169 文件处理 11610 数据库编程 116 1 Vc++2010开发平台概述1.1 Vc++2010概述 1.2 Visual Studio 2010 集成开发环境 1.2.1安装Visual Studio 2010 1.2.2配置Visual Studio 2010 1.2.3解决方案和项目 1.2.4生成和调试工具 1.2.5部署工具 1.2.6 Ribbon界面设计可视化 2 Visual Studio 2010 MFC基本程序设计2.1 MFC应用程序概述 2.1.1简单的MFC应用程序 2.1.2 MFC应用程序分析 2.2 MFC应用程序的创建 2.2.1 用AppWizard创建CLR控制台应用程序 2.2.2 用AppWizard创建win32控制台应用程序 2.2.3 用AppWizard创建一个MFC应用程序1.打开vc++2010，从起始页中选择“新建项目”如图2.2.3.1。 图2.2.3..1弹出图2.2.3.2所示界面，左侧选择“viaual c++语言”，中间选择“MFC 应用程序”，图2.2.3.2名称为huitu，位置为桌面，点击“确定”，弹出图2.2.3.3界面。 图2.2.3`.3然后一路点击下一步（或者直接点击“完成”），则自动生成一个MFC 应用程序，此时查看生成的程序文件夹内包含的文件，如图2.2.3.4 图2.2.3`.4Huitu文件夹内文件如图2.2.3.5 图2.2.3.5 点击启动调试工具拦（绿色三角，图2.2.3.6）或者按F5则系统调试运行，在弹出界面中选择是，弹出图2.2.3.7的程序运行界面。 图2.2.3.6 图2.2.3.7此时再看程序文件夹内的文件如图2.8 图2.2.3.8可以看见多了debug文件夹，分别打开debug文件夹以及huitu文件夹内的debug文件夹看看都多了啥文件。至此，一个文正的MFC应用程序建立完成。保存退出vc++2010，要再次进入刚才建立的应用程序，直接点击程序文件夹内的“huitu.sln”即可。 2.3 MFC的类 2.3.1 MFC应用程序中包含的类 2.3.2 应用程序类 2.3.3 主框架类 2.3.4 视图类 2.3.5 文档类 2.3.6 对话框类 2.3.7 菜单类 2.3.8 线程基类 3 Wndows窗体应用程序3.1 创建Wndows窗体应用程序1.启动vc++2010，如图3.1.1。 图3.1.12.选择新建项目在打开的窗口中，左侧语言选择vc++，窗口中间选择“windows窗体应用程序”，窗口下面“名称”填写form，工程位置为桌面（图3.1.2），点击确定，建成的应用程序界面如图3.1.3。 图3.1.2 图3.1.33.2 窗体属性及设置 3.3 窗体事件及处理 3.4 窗体控件添加与编辑 4 用户界面设计4.1 菜单设计4.1.1 菜单的类型 4.1.2 菜单设计建立菜单的过程如下：1.打开工程。打开前面建立的工程绘图（双击huitu工程文件夹中的huitu.sln）。2.打开资源视图。通过“视图-其他窗口-资源视图”菜单打开资源视图窗口，如图4.1.2.1，在vc++界面左侧显示资源视图窗口。 图4.1.2.13.添加菜单。点击资源视图的menu，展开如图4.1.2.2所示 图4.1.2.2可以看到在工程中有多个菜单，其中IDR_huituTYPE菜单是显示在各子文档界面中的菜单；IDR_MAINFRAME建立的菜单是程序主框架中显示的菜单（把所有子文档关闭后会显示）；在此双击IDR_huituTYPE，打开窗口如图4.1.2.3所示。 图4.1.2.3在请在此处键入位置点击，光标激活后输入“直线”，同时会在文本框右边和下面分别出现写有“请在此键入”字样的文本框，右边的代表键入的直线菜单的子菜单，下面代表直线菜单同级的菜单，其他以此类推，选择直线菜单后，查看vc++界面中右下角的属性面板，可以看到“popup”属性设置的是“true”，代表直线菜单是弹出式菜单，它下面还有下一级菜单，否则，该属性如果设置为“false”，则它不能再添加子菜单了。按照以上方法，在直线菜单下设置“直线1”，“直线2”两个子菜单，建立与直线同级的“圆”菜单，其下设置“圆1”，“圆2”两个子菜单，如图4.1.2.4。 图4.1.2.44.运行查看菜单。按F5或者点击启动调试工具（绿色三角箭头），在探出的窗口中选择是，启动运行后测绘看到建立的菜单（图4.1.2.5）。 图4.1.2.55.为菜单添加函数并且编写代码 菜单添加后还不能运行，要想让它起作用，需要为其添加函数并在函数里添加代码，为菜单添加函数过程为（以直线1为例）：选择直线1，在属性面板中把ID属性右边的值改为ID_line1,然后通过“项目-类向导”打开类向导窗口（图1.1.2.6） 图4.1.2.6类名处选择huituView，在命令标签列表中找到并点击ID_line1，在消息标签中点击COMMAND，如图4.1.2.7。I 图4.1.2.7再点击“添加处理程序”按钮，弹出添加函数对话框 图4.1.2.8成员函数名称默认（也可以修改），点确定，则与菜单直线1对应的函数生成，此时可通过点击图4.1.2.7中的“编辑代码”进入函数，或者在vc界面右上角的“解决资源管理器”面板中展开源代码（图4.1.2.8），找到huituView.CPP双击该文件也可进入函数。 图4.1.2.8在函数中的// TODO: 在此添加命令处理程序代码下面添加CClientDC dc(this);dc.LineTo(500,500);两句，如图4.1.2.9 图4.1.2.96.运行检验菜单功能按F5运行程序后点击直线1菜单，可以看到在用户区画出一条直线。4.1.3 创建弹出式菜单 4.1.4 创建动态菜单 4.1.5 创建基于对话框的菜单 4.2 工具栏设计 4.3 状态栏设计 5 对话框设计 5.1 静态对话框5.1.1静态对话框的建立过程建立静态对话框的过程如下：1.打开或建立工程。按照前面方法打开或者建立一个工程（MFC工程或者窗体应用程序均可，此处以mfc工程为例）2.打开资源窗口。通过“视图-其他窗口-资源视图”打开资源视图窗口。3.建立对话框。在资源视图的DIALOG文件夹上单击右键选择insert dialog，弹出新建的对话框，根据需要可以修改对话框属性面板中的属性值。4.添加对话框类。在建立的该对话框上双击鼠标左键，弹出添加类向导，根据提示设置好参数后确认，则建立了与对话框对应的对话框类。5.1.2静态对话框的应用对话框的应用一般是实现人机交互，以下结合huitu工程中的直线2菜单说明对话框的应用，功能为点击直线2菜单，弹出对话框，在对话框里设置好直线的起点与终点坐标并确认后在客户区画出设置的起点到终点的直线。1.打开工程。双击huitu.sln打开工程。2.添加对话框。通过“视图-其他窗口-资源视图”打开资源视图，在资源视图的DIALOG文件夹上单击右键选择insert dialog，弹出新建的对话框（图5.1.2.1），在属性面板中把对话框的ID属性修改为：IDD_line2_dlg。 图5.1.2.13.建立对话框类。在建立的对话框上双击鼠标左键，弹出建立对话框类向导，名称中输入line2dlg，基类选择CDIalog（图5.1.2.2）,点击完成，完成对话框类的建立，可以看到在解决资源管理器的头文件和源文件中已经建立了相应的件。 图5.1.2.24.添加控件。在对话框上从工具箱中添加四个静态文本框、四个编辑文本框、一个按钮，静态文本框的caption属性分别改为：起点x坐标，起点y坐标，终点x坐标，终点y坐标，按钮caption属性改为“确定”。如图5.1.2.3. 图5.1.2.35.为编辑文本框添加变量。要使用文本框，必须为其添加对应的变量，选择第一个文本框，点击“项目-类向导”菜单打开类向导，选择“成员变量”标签（图5.1.2.4），鼠标点击IDC_EDIT1（编辑文本框1对应的ID），点击右边的添加变量按钮弹出添加变量窗口。 图5.1.2.4 图5.1.2.5在变量设置窗口中，成员变量名称输入m_line1x，类别选择value，类型选择long（图5.1.2.5）.点确定。用同样的方法为其他三个编辑框添加变量，结果如图 5.1.2.6所示。 图5.1.2.66.为按钮添加函数，获取数据。为了点击按钮确定后获取坐标数据以便于画直线，需要为按钮添加函数，选择前面添加的按钮“确定”，通过“项目-类向导”菜单打开类向导，选择命令标签，点击确定按钮的ID（IDC_BUTTON1），点击消息列表中的BN_CLICKED（代表鼠标点击时触发函数或者事件运行），见图5.1.2.7，击添加处理程序，弹出处理程序对话框，默认之后点击确定则为按钮添加了对应的函数，双击line2dlg.cpp会看见添加了如下函数：void line2dlg::OnClickedButton1(){ // TODO: 在此添加控件通知处理程序代码 } 图5.1.2.77.编写代码获取数据。在前面添加的按钮函数中编写如下代码获取数据：UpdateData(true);CDialog::EndDialog(0); //结束对话框 该函数的作用是把输入文本框的坐标数据赋值到对应的变量中，即四个文本框对应的变量line1x,line1y,line1endx,line1endy。如果代码为UpdateData(false);则是指把变量中的数值显示到变量对应的文本框中。CDialog::EndDialog(0);是为了结束对话框。8.为菜单添加代码，画对话框设置坐标的的直线。点击资源视图中的menu文件夹展开，双击IDR_huituTYPE菜单，选择直线2菜单，把属性中的ID属性改为ID_line2，通过“项目-类向导”打开类向导，类名选择Chuituview,命令标签中的对象选择ID_line2，消息选择COMMAND（图5.1.2.8），点击添加处理程序，弹出窗口中默认确定，则自动打开ChuituView.cpp，并且光标定位到该函数中，代码如下：void ChuituView::OnLine2(){ // TODO: 在此命令处处理程序代码 } 图5.1.2.8定位到该代码窗口的最上端头文件处，添加以下一句： #include “line2dlg.h”目的是把对话框类包含进来，否则系统不认对话框中的信息。然后再online2()函数中添加如下代码：line2dlg dlg; //生成对话框对象 dlg.DoModal();//显示对话框 CClientDC dc(this);//生成设备环境对象，获取设备环境 dc.MoveTo(dlg.m_line1x,dlg.m_line1y);//定位到起点坐标 dc.LineTo(dlg.m_line1endx,dlg.m_line1endy);//从起点到终点画直线 9.运行程序。编译运行，点击直线2菜单会弹出对话框，在对话框中设置好起点终点坐标后点确定，则在客户区画出指定坐标的直线。5.2 非静态对话框 5.3 通用对话框 6常用控件6.1 公共控件 6.2 容器 6.3 数据控件 7 键盘鼠标事件7.1键盘事件为了使用户掌握键盘消息及其处理消息，介绍一个键盘消息处理实例。1.实例说明 本实例通过工程向导创建一个单文档工程，在其中响应键盘的WM_KEYDOWN、WM_KEYUP、WM_CHAR消息，实现下面的功能： 当用户按下了Shift键，在视图窗口中显示提示信息“用户按下了Shift键”； 当用户释放了Shift键时，在视图窗口中显示提示信息“用户释放了Shift键！”； 当用户按下了Shift键后又按下了字符“B”键，在视图窗口中显示提示信息“用户同时按下了Shift键和B键”（即输入B键或b键）。2.开发过程（1）创建工程。 利用MFC AppWizard[EXE]建立一个单文档的MFC工程“KeyboardDemo”。（2）在ClassView选项卡上用鼠标右键单击该类，并从弹出的快速菜单中选择[Add Member Variable…] 菜单命令，为KeyboardDemoView类添加一个新的成员变量bShiftdown,将此成员变量的类型设置为BOOL，并将其访问权限设置为Private, 单击[OK]按钮，完成成员变量的添加操作。按照同样的方法，再添加2个BOOL型private成员变量bShiftup和bShiftB， 接下来在KeyboardDemoView构造函数中给三个指示变量赋初值”false”。代码如下： CKeyboardDemoView::CKeyboardDemoView() { bShiftdown=bShiftup=bShiftB=false;//赋初值 }（3）利用“建立类向导”添加键盘消息及处理函数，步骤如下： 在”ClassName”列表框中，选择键盘消息的处理函数”CKeyboardDemoView”，在”Object IDs”列表框中选择“CKeyboardDemoView”， 则在“Message”列表框中，列出了MFC为其预定义的消息，分别选择WM_KEYDOWN、WM_KEYUP、WM_CHAR消息， 单击“Add Function”按钮，MFC就会为其自动添加相应的消息映射宏和消息处理函数。（4）添加实现代码：在资源文件“KeyboardDemoView.cpp”中添加各键盘消息函数的实现代码。 OnKeyDown函数的代码如下： void CKeyboardDemoView::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) { if(nChar==VK_SHIFT)//判断Shift键是否被按下 { bShiftdown=true; bShiftup=false; Invalidate(true); //显示信息 } CView::OnKeyDown(nChar, nRepCnt, nFlags); } 注：Invalidate(TRUE)将整个窗口设置为需要重绘的无效区域，它会产生WM_PAINT消息，这样OnDraw将被调用。OnKeyUp函数的代码如下： void CKeyboardDemoView::OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags) { if(nChar==VK_SHIFT)//判断Shift键是否被释放 { bShiftup=true; bShiftdown=false; Invalidate(true);//显示信息 } CView::OnKeyUp(nChar, nRepCnt, nFlags); }OnChar函数的代码如下： void CKeyboardDemoView::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags) { //判断是否同时敲击了字符键B键和Shift键 if((nChar==’b’)|(nChar==’B’)) //if((nChar==66)|(nChar==98)) { if(bShiftdown) { bShiftB=true; bShiftdown=false; Invalidate(true); } } CView::OnChar(nChar, nRepCnt, nFlags); }在资源文件”KeyboardDemoView.cpp”的OnDraw函数中，实现在客户区窗口输出按键提示信息。代码如下： void CKeyboardDemoView::OnDraw(CDC* pDC) { if(bShiftdown)//按下了Shift键 { pDC-&gt;TextOut(20,20,”用户按下了Shift键!”); } if(bShiftup)//释放了Shift键 { pDC-&gt;TextOut(20,20,”用户释放了Shift键!”); } if(bShiftB)//同时按下了Shift键和B键 { pDC-&gt;TextOut(20,20,”用户同时按下Shift键和B键!”); bShiftB=false; } } 举例：CDC pDC =GetDC(); if (nChar==VK_UP) { pDC-&gt;Ellipse(40,40,200,200); }键盘事件总结：Vc++中键盘事件中函数原型如下（以键盘按下为例，其他类似）OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)其中：nChar ：表示按键的字符代码。nRepCnt：表示按键的重复次数。nFlags：表示扫描码、先前键状态、键转换状态等。nChar的取值表：虚拟键码 对应值 对应键VK_LBUTTON 1 鼠标左键VK_RBUTTON 2 鼠标右键VK_CANCEL 3 CancelVK_MBUTTON 4 鼠标中键VK_XBUTTON1 5VK_XBUTTON2 6VK_BACK 8 BackspaceVK_TAB 9 TabVK_CLEAR 12 ClearVK_RETURN 13 EnterVK_SHIFT 16 ShiftVK_CONTROL 17 CtrlVK_MENU 18 AltVK_PAUSE 19 PauseVK_CAPITAL 20 Caps LockVK_KANA 21VK_HANGUL 21VK_JUNJA 23VK_FINAL 24VK_HANJA 25VK_KANJI 25VK_ESCAPE 27 EscVK_CONVERT 28VK_NONCONVERT 29VK_ACCEPT 30VK_MODECHANGE 31VK_SPACE 32 SpaceVK_PRIOR 33 Page UpVK_NEXT 34 Page DownVK_END 35 EndVK_HOME 36 HomeVK_LEFT 37 Left ArrowVK_UP 38 Up ArrowVK_RIGHT 39 Right ArrowVK_DOWN 40 Down ArrowVK_SELECT 41 SelectVK_PRINT 42 PrintVK_EXECUTE 43 ExecuteVK_SNAPSHOT 44 SnapshotVK_INSERT 45 InsertVK_DELETE 46 DeleteVK_HELP 47 Help 48 0 49 1 50 2 51 3 52 4 53 5 54 6 55 7 56 8 57 9 65 A 66 B 67 C 68 D 69 E 70 F 71 G 72 H 73 I 74 J 75 K 76 L 77 M 78 N 79 O 80 P 81 Q 82 R 83 S 84 T 85 U 86 V 87 W 88 X 89 Y 90 ZVK_LWIN 91VK_RWIN 92VK_APPS 93VK_SLEEP 95VK_NUMPAD0 96 小键盘 0VK_NUMPAD1 97 小键盘 1VK_NUMPAD2 98 小键盘 2VK_NUMPAD3 99 小键盘 3VK_NUMPAD4 100 小键盘 4VK_NUMPAD5 101 小键盘 5VK_NUMPAD6 102 小键盘 6VK_NUMPAD7 103 小键盘 7VK_NUMPAD8 104 小键盘 8VK_NUMPAD9 105 小键盘 9VK_MULTIPLY 106 小键盘 *VK_ADD 107 小键盘 +VK_SEPARATOR 108 小键盘 EnterVK_SUBTRACT 109 小键盘 -VK_DECIMAL 110 小键盘 .VK_DIVIDE 111 小键盘 /VK_F1 112 F1VK_F2 113 F2VK_F3 114 F3VK_F4 115 F4VK_F5 116 F5VK_F6 117 F6VK_F7 118 F7VK_F8 119 F8VK_F9 120 F9VK_F10 121 F10VK_F11 122 F11VK_F12 123 F12VK_F13 124VK_F14 125VK_F15 126VK_F16 127VK_F17 128VK_F18 129VK_F19 130VK_F20 131VK_F21 132VK_F22 133VK_F23 134VK_F24 135VK_NUMLOCK 144 Num LockVK_SCROLL 145 ScrollVK_LSHIFT 160VK_RSHIFT 161VK_LCONTROL 162VK_RCONTROL 163VK_LMENU 164VK_RMENU 165VK_BROWSER_BACK 166VK_BROWSER_FORWARD 167VK_BROWSER_REFRESH 168VK_BROWSER_STOP 169VK_BROWSER_SEARCH 170VK_BROWSER_FAVORITES 171VK_BROWSER_HOME 172VK_VOLUME_MUTE 173 VolumeMuteVK_VOLUME_DOWN 174 VolumeDownVK_VOLUME_UP 175 VolumeUpVK_MEDIA_NEXT_TRACK 176VK_MEDIA_PREV_TRACK 177VK_MEDIA_STOP 178VK_MEDIA_PLAY_PAUSE 179VK_LAUNCH_MAIL 180VK_LAUNCH_MEDIA_SELECT 181VK_LAUNCH_APP1 182VK_LAUNCH_APP2 183VK_OEM_1 186 ; :VK_OEM_PLUS 187 = +VK_OEM_COMMA 188VK_OEMMINUS 189 - VK_OEM_PERIOD 190VK_OEM_2 191 / ?VK_OEM_3 192 ` ~VK_OEM_4 219 [ {VK_OEM_5 220 \ |VK_OEM_6 221 ] }VK_OEM_7 222 ‘ “VK_OEM_8 223VK_OEM_102 226VK_PACKET 231VK_PROCESSKEY 229VK_ATTN 246VK_CRSEL 247VK_EXSEL 248VK_EREOF 249VK_PLAY 250VK_ZOOM 251VK_NONAME 252VK_PA1 253VK_OEM_CLEAR 254 7.2 鼠标事件7.2.1客户区鼠标消息当鼠标通过客户区时，就会触发客户区鼠标消息。常用的客户区鼠标消息消息名称 消息说明WM_LBUTTONDBLCLK 鼠标左键被双击WM_LBUTTONDOWN 鼠标左键被按下WM_LBUTTONUP 鼠标左键被释放WM_MBUTTONDBLCLk 鼠标中键被双击WM_MBUTTONDOWN 鼠标中键被按下WM_MBUTTONUP 鼠标中键被释放WM_MOUSEMOVE 鼠标移动穿过客户区域WM_RBUTTONDBLCLK 鼠标右键被双击WM_RBUTTONDOWN 鼠标右键被按下WM_RBUTTONUP 鼠标右键被释放WM_MOUSEWHEEL 在客户区内鼠标滚轮滚动应用程序一般是处理客户区鼠标消息。非客户区鼠标消息可以被Windows本身妥善的处理。 客户区鼠标消息处理函数的一般形式为： void OnXxxYyy(UINT nFlag, CPoint point); 如WM_LBUTTONDOWN的消息处理函数，其声明如下： void OnLButtonDown(UINT nFlag, CPoint point); 函数的两个参数说明如下： point：为CPoint类对象，记录了当前光标的x,y坐标，这个坐标是以相对于窗口客户区左上角的设备坐标而言的。 nFlags：为鼠标动作的条件标志，取值是以下各种取值的组合。各取值含义如下：MK_LBUTTON: 按下了鼠标的左键。MK_MBUTTON: 按下了鼠标的中键。MK_RBUTTON: 按下了鼠标的右键。MK_CONTROL: 按下了键盘上的Ctrl键。MK_SHIFT: 按下了键盘上的Shift键。在实际编程中，常使用nFlags参数与以上可能取值进行位与运算，来判断消息生成时的鼠标键以及Shift以及Ctrl的状态。 如检测Shift键和Ctrl键的状态，如下： void OnLButtonDown(UINT nFlags,CPoint point) { //判断是否Ctrl键和Shift键同时按下 if((nFlags&amp;MK_CONTROL)&amp;&amp;(nFlags&amp;MK_SHIFT)) …… } void CMouseDemoView::OnMouseMove(UINT nFlags, CPoint point) { //移动鼠标时鼠标左键是按下的 if((nFlags&amp;MK_LBUTTON) == MK_LBUTTON) { … } … }鼠标捕捉 如果你的鼠标移出了某个窗口的客户区范围，那么此窗口将不再继续收到客户区鼠标消息。 SetCapture和ReleaseCapture 如果你用SetCapture进行了鼠标捕捉，那么，即使你的鼠标移出了窗口客户区，仍然可以收到客户区鼠标消息，直到调用ReleaseCapture释放鼠标捕捉或在某个窗口上进行点击为止。 注意： 一旦某个窗口捕获了鼠标，其他窗口将无法得到鼠标消息。 因此，当窗口不再需要捕获鼠标消息时，应及时使用ReleaseCapture函数将鼠标释放。 7.2.2非客户区鼠标消息当鼠标通过非客户区时，就会触发非客户区鼠标消息。常见的非客户区鼠标消息消息名称 消息说明WM_NCLBUTTONDBLCLK 鼠标左键被双击WM_NCLBUTTONDOWN 鼠标左键被按下WM_NCLBUTTONUP 鼠标左键被释放WM_NCMBUTTONDBLCLK 鼠标中键被双击WM_NCMBUTTONDOWN 鼠标中键被按下WM_NCMBUTTONUP 鼠标中键被释放WM_NCMOUSEMOVE 鼠标移动穿过客户区域WM_NCRBUTTONDBLCLK 鼠标右键被双击WM_NCRBUTTONDOWN 鼠标右键被按下WM_NCRBUTTONUP 鼠标右键被释放 7.2.3实例1.鼠标消息的处理及鼠标相关的操作。 实例说明： 通过工程向导创建一个单文档工程，在其中响应鼠标的WM_LBUTTONDOWN、WM_LBUTTONUP、WM_MOUSEMOVE消息 实现功能： 当按下鼠标左键并移动鼠标时，在客户区窗口内将绘制鼠标的移动轨迹，同时光标变为“十字”光标或自定义光标。 当按下鼠标左键时，鼠标的移动范围被限制的整个客户区窗口范围时，即鼠标不能移到客户区外。 当释放了鼠标左键后，鼠标恢复原来的活动区域。开发步骤： (1)创建工程。启动Visual C++,利用MFC APPWizard[EXE]建立一个新的MFC工程，工程名为“MouseDemo”, 在MFC AppWizard Step1的时候选择“Single documents”即基于单文档的MFC工程，之后的步骤使用默认值。 (2)利用“ClassWizard”添加鼠标消息及处理函数： 在”ClassName”列表框中，选择鼠标消息的处理类”CMouseDemoView”，在“Message”列表框中， 列出了MFC预定义的消息，分别选择WM_LBUTTONDOWN、WM_LBUTTONUP、WM_MOUSEMOVE消息，单击“Add Function”按钮， MFC就会为其自动添加相应的消息映射宏和消息处理函数。 (3)添加实现代码 首先在头文件”MouseDemoView.h”中声明变量startpoint、rcOldClip。 代码如下： public: CPoint startpoint; RECT rcOldClip;添加WM_LBUTTONDOWN的消息处理代码如下： void CMouseDemoView::OnLButtonDown(UINT nFlags, CPoint point) { GetClipCursor(&amp;rcOldClip);//获取原鼠标活动的有效区域 startpoint=point; //鼠标所在点为起始点 SetCapture(); //进行鼠标捕捉 CView::OnLButtonDown(nFlags, point); }添加WM_LBUTTONUP的消息处理代码如下： void CMouseDemoView::OnLButtonUp(UINT nFlags, CPoint point) { ClipCursor(&amp;rcOldClip);//恢复原来的鼠标活动区域 ReleaseCapture(); //释放鼠标捕捉 CView::OnLButtonUp(nFlags, point); }添加WM_MOUSEMOVE的消息处理代码如下： void CMouseDemoView::OnMouseMove(UINT nFlags, CPoint point) { CDC * pDC=GetDC(); //获得DC HCURSOR cursor; //鼠标光标句柄 RECT rcClip; //限制矩形区域 if((nFlags&amp;MK_LBUTTON) == MK_LBUTTON) //移动鼠标时鼠标左键是按下的 { GetWindowRect(&amp;rcClip); //获取客户区窗口区域 ClipCursor(&amp;rcClip); //将鼠标的移动限制的客户区 cursor=AfxGetApp()-&gt;LoadStandardCursor(IDC_CROSS); //载入标准十字光标 SetCursor(cursor); //使用新光标 pDC-&gt;MoveTo(startpoint.x,startpoint.y); //开始画线 pDC-&gt;LineTo(point.x,point.y); startpoint=point; } CView::OnMouseMove(nFlags, point); } (4)编译运行程序解释： （1）在鼠标消息响应函数中，根据参数nFlags可以判断鼠标的左、右、中键以及键盘上的Shift键和Ctrl键的按下状态。 在本例的OnMouseMove()函数中，就利用nFlags参数判断鼠标左键是否被按下来完成画线功能。 （2）当按下鼠标左键并移动鼠标时，在OnMouseMove()函数中通过调用API函数ClipCursor()将鼠标的活动区域限制在客户区窗口中。 而当鼠标左键释放时，在函数OnLButtonUp()中，通过ClipCursor()将鼠标的活动区域恢复为原来状态。 2.实例2：CDC* pDC =GetDC(); if (nFlags==MK_LBUTTON) { pDC-&gt;LineTo(point.x,point.y); } CView::OnLButtonDown(nFlags, point); 3.实例3：CDC pDC =GetDC(); CPen pen; pen.CreatePen(PS_SOLID,5,RGB(255,0,0)); CPen pOldPen=pDC-&gt;SelectObject(&amp;pen); if (nFlags==MK_LBUTTON) { pDC-&gt;MoveTo(400,300); pDC-&gt;LineTo(point.x,point.y); } pDC-&gt;SelectObject(pOldPen);4.实例4：CDC pDC =GetDC(); CPen pen; pen.CreatePen(PS_SOLID,2,RGB(255rand(),255rand(),255rand())); CPen pOldPen=pDC-&gt;SelectObject(&amp;pen); int i; if (nFlags==MK_LBUTTON) { for(i=1;iMoveTo(point.x,point.y); pDC-&gt;LineTo(400rand(),400rand()); } } pDC-&gt;SelectObject(pOldPen); ReleaseDC(pDC); //释放DC实例5CDC pDC =GetDC(); CPen pen; pen.CreatePen(PS_SOLID,2,RGB(255rand(),255rand(),255rand())); CPen pOldPen=pDC-&gt;SelectObject(&amp;pen); CRect rect(30,40,point.x,point.y); pDC-&gt;Rectangle(&amp;rect); // 绘制矩形 pDC-&gt;SelectObject(pOldPen); ReleaseDC(pDC); //释放DC 判断是哪一个字符键也可以：Char keychar;Keychar = char(nChar)If (keychar=”a”)…..其中nChar为键盘事件中的一个参数8 图形文本与图像处理8.1图形设备接口GDI（Graphics Device Interface）GDI（Graphics Device Interface，图形设备接口）是Windows操作系统的传统图形子系统，负责与设备无关的图形绘制，Win32 API为应用程序提供了丰富的绘图函数和功能，MFC对它们进行了C++类封装，参见图8-1。Windows应用程序 MFCWin32 API执行程序 用户界面（User） GDI+ 图形子系统（GDI）设备驱动程序 内核（Kernel） 图形驱动程序硬件抽象层（HAL）计算机硬件图8-1 GDI与Windows操作系统（其中彩色部分为操作系统）传统GDI是随Windows 1.0于1985年11月推出的，新式GDI+则是随Windows XP于2001年10月推出的GDI的改进版，增加了α混色、渐变画刷、样条曲线、矩阵变换、图像处理、持久路径等新功能。随Windows Vista及.NET框架3.0微软于2006年11月又推出了基于DirectX和.NET框架的全新图形子系统WPF（Windows Presentation Foundation，视窗显示/展现基础），它统一了桌面和浏览器等客户端应用程序的图形界面，采用XAML声明式编程，将用户界面的设计和编程彻底分离开来，是Windows的下一代GUI显示系统。GDI+是建立在GDI之上的。WPF则是以.NET框架为基础的。在MFC中，CGdiObject类是GDI对象的基类，而CGDIObject则是直接从CObject类派生的抽象基类,通过查阅MSDN我们可以看到，CGdiObject类有六个直接的派生类，GDI对象主要也是这六个，分别是：CBitmap、CBrush、CFont、CPalette、CPen和CRgn。 CRgn为区域（region）类，对应于窗口中的一个矩形、多边形或（椭）圆区域，可用于移动、拷贝、合并、判断和裁剪。GDI负责系统与用户或者绘图程序之间的信息交换，并控制在输出设备上显示图形或文字。将GDI对象用SelectObject函数选入DC后，就可利用对应的绘图工具进行图形绘制。可用CDC类的多态成员函数SelectObject，将绘图工具对象选入DC，以供绘图时使用：CPen SelectObject( CPen pPen );CBrush SelectObject( CBrush pBrush );virtual CFont SelectObject( CFont pFont );CBitmap SelectObject( CBitmap pBitmap );int SelectObject( CRgn pRgn );CGdiObject SelectObject( CGdiObject* pObject ); 8.2 设备上下文DC（device context）8.2.1 设备上下文概述在GDI中，DC(Device context)是一个非常重要的概念。有的书中，将DC翻译为设备描述表（《Windows 程序设计 第五版》作者Charles Petzold），也有的书将DC翻译为设备上下文。到底什么是DC？用现实中的例子来理解可能更容易些。如果你喜欢画画，你得先准备了画布，画笔，颜料……画画的环境搭建好了，你就可以画画了。这个画画的环境，就是DC。在图形环境下，一切都是画出来的，所以，你要准备好一个DC，才能在屏幕上画画。——写字也是画画。在画画的环境中，有哪些对象呢？画布——GDI对象之一：区域画笔——GDI对象之一：画笔颜料盒——GDI对象之一：调色板如果要在画笔上写字的话，写什么样的字体呢？方正字体？—字体也是GDI对象之一。有的画笔比较粗，专用来刷大面积背景色的，这是刷子——GDI对象之一：刷子如果你不想画了，只想把别人画好的画，贴到你的画布上，这也是可以的。——GDI对象之一：位图。所以，这里就有6种GDI对象可以用于DC。现在开始画画了，你拿起了一只笔。——在Windows环境里，这叫选择了一个画笔对象：使用SelectOBject函数。当然，如果你没带笔也没关系，Windows为你准备了几只画笔，你可以这样申请系统提供的缺省画笔：hPen = GetStockObject(WHITE_PEN);如果你画着画着，觉得手中的笔用着不爽，可以换一只啊，没关系的。——依旧是SelectObject()换笔。当然，如果你走出了画室，别完了把你的画笔清除掉，要不画室里全是笔啊，刷子啊，太乱了。——DeleteObject()所以对DC可以这样理解:每一笔用GDI画的都通过它与设备交流最终画在屏幕上不同屏幕/设备它不同,所以可以保证画出的效果相同,增加程序的可移植性也就是GDI是画在DC上的,DC再显示在屏幕上DC为GDI基础通过GDI绘制出来时看不到的也就是不显示的,只在内存上的一副图片,这幅图可以通过DC绘制在设备上有几种常见环境:1）显示设备环境主要用于显示设备上的绘制操作，当应用绘制客户区时，它需要调用BeginPaint、GetDC或GetDCEx函数获取显示设备上下文。绘制结束后，需要调用EndPaint或ReleaseDC函数释放它。2）打印机设备环境应用程序以合适的参数（如打印机驱动名、打印机名等）调用函数CreateDC，完成打印任务后，就会调用DeleteDC，以删除打印机设备上下文。3）内存设备环境主要为特定的设备存储位图，它支持在位图上进行绘制操作。通常通过调用CreateCompatibleDC来获取内存设备上下文，当系统处理这个调用时，它将在内存中创建一个和原始设备颜色格式兼容的位图。内存设备上下文将系统内存用作显示表面，通常使用内存设备上下文预先在系统内存中绘制复杂的图形，然后再快速地将其复制到实际的设备上下文的显示表面上，而绘制图形的结果仍保存在内存设备上下文的DDB中。4）信息设备环境主要用于获取默认设备的数据。如调用函数CreateIC，以便为打印机的特定模型创建信息设备上下文，然后调用函数GetCurrentObject和GetObject来获取默认的画笔和画刷的属性。在使用完信息设备上下文之后，需调用DeleteDC以删除设备上下文。设备描述表（DC）是Windows中的一种数据结构，它包含GDI需要的所有关于显示界面情况的描述字段，包括相连的物理设备和各种各样的状态信息。在Windows画图之前，Windows程序从GDI获取设备描述表句柄（HDC）,并在每次调用完GDI输出函数后将句柄返回给GDI。GDI函数中使用该句柄的数据信息来在设备上下文环境中绘图DC好比画图用的画纸，GDI就是画图时用的工具。在Windows中，绘图包括绘制图形、显示位图和输出文字，它们都需要使用绘图环境DC（Device-Context, 设备上下文）。MFC将DC结构和所有的绘图函数、绘图对象的访问函数、绘图模式与参数的设置函数都封装到了CDC类中。8.2.2 CDC类CDC类是MFC对DC结构及其相关绘图和状态设置函数的C++类封装。CDC是CObject的直接派生类，CDC类自己也有若干派生类，其中包括：窗口客户区DC所对应的CClientDC类、OnPaint和OnDraw消息响应函数的输入参数中使用的CPaintDC类、图元文件对应的CMetaFileDC类和整个窗口所对应的CWindowDC类，参见图8-3。在普通的MFC绘图中，一般直接使用CDC类即可。 CDC类CDC类中有许多成员函数，可以用来设置各种绘图环境、属性和参数，以及绘制各种图形和图像等，将在后面陆续加以介绍。1．获得DC在OnDraw函数中应该使用输入参数pDC，在其他函数中则可调用从CWnd类继承的成员函数GetDC来获得当前窗口（如客户区/视图类）DC的指针，该函数的原型为：CDC GetDC( );注意，每次从OnDraw函数的输入参数或调用GetDC所获得的DC，都是一个全新的临时默认DC，具有默认的绘图环境和设置。它不能用类变量来长期保存，而且原来选入的各种GDI对象全都被作废、原来设置的各种状态也失效，一切都必须从头再来。2．释放DC因为Windows限制可用DC的数量，所以DC属于稀缺的公用资源。因此，对每次获得的DC，在使用完成后必须立即释放。从OnDraw函数的输入参数pDC获得的DC，在该函数运行结束后，系统会自动释放。但由GetDC所获得的DC，则必须自己来手工释放，这可以通过调用从CWnd类继承的成员函数ReleaseDC来完成。该函数的原型为：int ReleaseDC( CDC pDC ); // 成功返回非0例如：void CDrawView::OnLButtonUp(UINT nFlags, CPoint point){ CDC pDC = GetDC(); // 获取DC pDC-&gt;SelectObject(&amp;pen); // 选入笔 pDC-&gt;Rectangle(&amp;rect); // 绘制矩形 ReleaseDC(pDC); // 释放DC CView::OnLButtonUp(nFlags, point);}3．安全DC句柄可以用CDC类的成员函数GetSafeHdc来获取DC所对应窗口（如客户区）的安全DC句柄，该函数的原型为：HDC GetSafeHdc();与用GetDC函数所得到的临时DC不同，该安全DC句柄在窗口的存在期间内一直是有效的。例如，可先定义类变量HDC m_hDC;，再在适当的地方给它赋值m_hDC = GetDC()-&gt;GetSafeHdc();，然后就可以放心地使用了。还可以使用CDC类的成员函数Attach来将一空CDC对象与此安全DC句柄连接在一起，该函数的原型为：BOOL Attach(HDC hDC); // 成功返回非04．屏幕DC可以以NULL为输入参数，调用全局的API函数GetDC：HDC GetDC(HWND hWnd);来可获取屏幕DC的句柄。例如：HDC hdc = ::GetDC(NULL); // 获取屏幕DC的句柄Ellipse(hdc, 0, 0, 150, 100); // 用API函数在屏幕左上角画一椭圆也可以利用CDC类的成员函数Attach，将屏幕DC的句柄选入自定义的CDC类中，来 构造屏幕CDC类的对象。例如： HDC hdc = ::GetDC(NULL); // 获取屏幕DC的句柄 CDC sDC; // 定义屏幕DC（空）对象 sDC.Attach(hdc); // 粘上屏幕DC句柄 sDC.Ellipse(0, 0, 150, 100); // 在屏幕左上角画一椭圆8.3 绘图环境8.3.1绘图环境介绍在Windows中，绘图一般在框架窗口的客户区（对应于视图类CView）进行，使用的是封装在MFC的设备上下文（Device-Context，DC）类CDC中的各种绘图函数。在绘图前，一般需先得到客户区大小和CDC对象、设置绘图颜色，然后再根据文档数据或用户操作来绘制各种图形。当然，如果没有特殊要求，最简单的就是直接生成CDC对象，通过对象调用画图函数画图，只是此时颜色是默认黑色，线宽为一个像素的实线图。8.3.2映射模式与坐标系在Windows中，绘图一般在视图窗口的客户区进行，使用的是设备上下文类CDC中各种绘图函数。为了达到理想的绘图效果，有时需要先利用CDC类设置绘图所用的坐标系（映射模式）和各种绘图属性。在Windows中，绘图都是在当前的映射模式（map mode）下（坐标系中）进行的。而当前映射模式可以用CDC类的成员函数SetMapMode来设置。一、默认映射模式映射模式影响所有的图形和文本绘制函数，它定义（将逻辑单位转换为设备单位所使用的）度量单位和坐标方向，Windows总是用逻辑单位来绘图。默认情况下，绘图的默认映射模式为MM_TEXT，其绘图单位为像素（只要不打印输出，屏幕绘图使用该模式就够了）。若窗口客户区的宽和高分别为w和h像素，则其x坐标是从左到右，范围为0 ~ w-1；y坐标是从上到下，范围为0 ~ h-1，参见图8-7。 图8-7 默认的MM_TEXT 图8-8 非自定义且非MM_TEXT映射映射模式下的窗口坐标系 模式下的（初始）窗口坐标系（注意y在当前窗口中的坐标值为负）二、设置映射模式（坐标模式）可使用CDC类的成员函数GetMapMode和SetMapMode来获得和设置当前映射模式：int GetMapMode( ) const; // 返回当前的映射模式virtual int SetMapMode( int nMapMode ); // 返回先前的映射模式映射模式nMapMode的取值见表8-7。表8-7 映射模式的nMapMode取值与含义符号常量 数值 x方向 y方向 逻辑单位MM_TEXT 1 向右 向下 像素MM_LOMETRIC 2 向右 向上 0.1 mmMM_HIMETRIC 3 向右 向上 0.01 mmMM_LOENGLISH 4 向右 向上 0.01 inMM_HIENGLISH 5 向右 向上 0.001 inMM_TWIPS 6 向右 向上 1/1440 inMM_ISOTROPIC 7 自定义 自定义 自定义MM_ANISOTROPIC 8 自定义 自定义 自定义其中，in为英寸，1 in = 2.54 cm；twips（缇）是一种打印标准单位；isotropic（各向同性的），指x与y方向的单位相同；和anisotropic（各向异性的），则是指x与y方向的单位可不同。可见，除了两种自定义映射模式外，x方向都是向右，y方向也只有MM_TEXT的向下，其余的都是向上，与数学上坐标系一致，参见图8-8。除了MM_ANISOTROPIC外，其他所有映射模式的x与y方向的单位都是相同的。所有映射模式的逻辑坐标的原点（0, 0）最初都是在窗口的左上角，但在CScrollView的派生类中，MFC会随用户滚动文档而自动调整逻辑原点的相对位置（改变视点的原点属性）。三、单位转换对所有非MM_TEXT映射模式，有如下重要规则： CDC的成员函数（如各种绘图函数）具有逻辑坐标参数。 CWnd的成员函数（如各种响应函数）具有设备坐标参数（如鼠标位置point）。 位置的测试操作（如CRect的PtInRect函数）只有使用设备坐标时才有效。 长期使用的值应该用逻辑坐标保存（如窗口滚动后保存的设备坐标就无效了）。因此，为了使应用程序能够正确工作，除MM_TEXT映射模式外，其他映射模式都需要进行单位转换。Windows的GDI负责逻辑坐标和设备坐标之间的转换，这可以调用CDC类的成员函数LPtoDP和DPtoLP来进行：void LPtoDP( LPPOINT lpPoints, int nCount = 1 ) const;void LPtoDP( LPRECT lpRect ) const;void LPtoDP( LPSIZE lpSize ) const;void DPtoLP( LPPOINT lpPoints, int nCount = 1 ) const;void DPtoLP( LPRECT lpRect ) const;void DPtoLP( LPSIZE lpSize ) const;例如：void CDrawView::OnLButtonDown(UINT nFlags, CPoint point) { CRect rect = m_rect; // 逻辑坐标 CClientDC dc(this); dc.SetMapMode(MM_LOENGLISH); dc.LPtoDP(rect); // 转化成设备坐标 // 位置的测试操作只有在使用设备坐标时才有效 if (rect.PtInRect(point)) ……}void CDrawView:: OnMouseMove (UINT nFlags, CPoint point) { float t,y; char buf[40]; CDC pDC = GetDC(); pDC-&gt;SetMapMode(MM_HIMETRIC); pDC-&gt;DPtoLP(&amp;point); // 转化成逻辑坐标 t = t1 + (point.x dt) / w; sprintf(buf, “%.4fs”, t); pSB-&gt;SetPaneText(xV, buf); y = (y0 - point.y) / dy; sprintf(buf, “%.4f”, y); pSB-&gt;SetPaneText(yV, buf); ……}四、建立自己需要的坐标系建立一个合适的坐标系可以为我们的绘图带来很大的方便。下面介绍一下如何在VC中建立我们想要的坐标系。(一)设备坐标和逻辑坐标设备坐标（Device Coordinate）又称为物理坐标（Physical Coordinate），是指输出设备上的坐标。通常将屏幕上的设备坐标称为屏幕坐标。设备坐标用对象距离窗口左上角的水平距离和垂直距离来指定对象的位置，是以像素为单位来表示的，设备坐标的X轴向右为正，Y轴向下为正，坐标原点位于窗口的左上角。逻辑坐标（Logical Coordinate）是系统用作记录的坐标。在缺省的模式（MM_TEXT）下，逻辑坐标的方向和单位与设备坐标的方向和单位相同，也是以像素为单位来表示的，X轴向右为正，Y轴向下为正，坐标原点位于窗口的左上角。逻辑坐标和设备坐标即使在缺省模式下其数值也未必一致，除了在以下两种情况下： 窗口为非滚动窗口 窗口为滚动窗口，但垂直滚动条位于滚动边框的最上端，水平滚动条位于最左端，但如果移动了滚动条这两种坐标就不一致了。在VC中鼠标坐标的坐标位置用设备坐标表示，但所有GDI绘图都用逻辑坐标表示，所以用鼠标绘图时，那么必须将设备坐标转换为逻辑坐标，可以使用CDC 函数DptoLP（）将设备坐标转化为逻辑坐标，同样可以用LptoDP（）将逻辑坐标转化为设备坐标。///////////////////MFC逻辑坐标原点与设备坐标原点的移动①原点概念的理解：在数学中常称点（0，0）为坐标原点，但是在windows中原点是一个坐标，但并未必是（0，0）点。原点这个说法的使用时为了联系设备坐标和逻辑坐标—设备坐标的原点一定要和逻辑坐标的原点重合。②映射模式被定义为从窗口（window也即逻辑坐标）到视口（viewport也即设备坐标）的映射，具体的内容可以参考：《MFC Windows 程序设计》P36和《Windows程序设计》P147。③既然用坐标来标注设备坐标系和逻辑坐标系的原点，那么二者坐标值的求取必须具有同一个参考对象，也就是说必须有一个参考点来确定设备坐标中原点和逻辑坐标中的原点的坐标。在windows中选择设备坐标点（0，0）为参考点，设备坐标点（0，0）始终都位于客户区的左上角。（《Windows程序设计》P147）④传送给CDC输出函数的是逻辑坐标，《MFC Windows 程序设计》P36⑤逻辑坐标：可理解成几何作业本上的直角坐标系，坐标值是无限的，Windows的绘图是以逻辑坐标作为参数，也就是说Windows绘图是在逻辑平面上进行的。设备坐标：是物理的，就理解成手上拿着的方形框框（如显示器），通过该方框可以看到在逻辑平面上所画的东西。设备坐标的左上角永远是（0，0）点，且X轴的正方向向右，Y轴的正方向向下。设备总是有尺寸的，只能显示某个范围的内容。默认情况下，逻辑坐标采用MM_TEXT映射模式，该映射模式下逻辑坐标的方向与设备坐标系的方向相同：X轴的正方向向右，Y轴的正方向向下。再加上坐标原点重合，故给人的感觉是只有一个坐标系，具体如图1所示： 图1⑥举例说明SetWindowOrg和SetViewportOrg的使用在默认的情况下逻辑坐标到设备坐标的映射模式为：MM_TEXT，为方便起见这里不再更改映射模式，在默认的情况下：窗口原点为（0，0）点，视口原点也为（0，0）点。假设将设备原点移到窗口的中心点，即现有的视口原点不再是（0，0）而是窗口中心点。设dc为一个设备描述表对象，具体实现如下：CRect rect;GetClientRect (&amp;rect);//返回的是设备坐标，而SetViewportOrg需要的也是设备坐标，故此处不用转换dc.SetViewportOrg (rect.Width ()/2, rect.Height ()/2);图解分析如图2所示： 图2具体分析：Ⅰ：将视口原点由（0，0）点移至（x,y）等价于把逻辑点（0，0）映射成设备点（x,y）。Ⅱ：设备坐标原点与逻辑坐标原点必须重合。Ⅲ：默认情况下逻辑坐标的原点为（0,0）点，且本处只移动了设备坐标原点，并没有移动逻辑坐标原点，故逻辑坐标的原点仍为（0,0）点，不过要满足Ⅱ中的条件，逻辑坐标系发生了移动，移动结果如图2所示，此时移动后的设备原点（rect.Width ()/2, rect.Height ()/2）与逻辑原点（0,0）重合。⑦在上面的⑥中将视口原点移到视口的中点，并完成了将逻辑原点到视口中点的映射。为达到相同的效果，用SetWindowOrg移动逻辑坐标原点也可以达到相同的效果。为使理解更加清晰透彻，这里做了两组对比的实验实验一： CRect rect; GetClientRect (&amp;rect); CPoint point (rect.Width () / 2, rect.Height () / 2); dc.DPtoLP (&amp;point); dc.SetWindowOrg (point.x, point.y);该实验的逻辑坐标原点移动的示意图如图3所示： 图3在图3中若进行正常移动则逻辑原点将移至设备坐标系的中点，为保证逻辑原点与设备原点的重合，必须移动设备原点（注：由于设备原点没有移动，仍是（0,0）点），但是根据规定设备坐标点是不能移动的，由前面的③可知，作为参考点的设备点（0,0）是不能移动的，不过此处设备点（0,0）恰好又是设备原点而已，故不能移动。既然设备原点不能移动，却又要满足逻辑坐标原点（point.x, point.y）与设备坐标原点（0,0）的重合，只能进行等价移动逻辑坐标系，移动如图3所示：很明显逻辑坐标原点为（point.x, point.y）且满足改点与设备坐标原点（0,0）的重合。不过对比图2，很明显通过对设备坐标原点进行该种移动不能达到相同的效果，即实验一并未得到与⑥中同样的结果。实验二： CRect rect; GetClientRect (&amp;rect); CPoint point (rect.Width () / 2, rect.Height () / 2); dc.DPtoLP (&amp;point); dc.SetWindowOrg (-point.x, -point.y);该实验的逻辑坐标原点移动的示意图如图4所示： 图4具体的分析与实验一类似，这里不再赘述了，与图2对比很明显得到：对逻辑坐标原点进行这种移动可达到与移动设备坐标原点相同的效果，但有一点值得注意：达到的效果相同，但进行这种移动后设备坐标原点为（0,0）,逻辑坐标原点为（-point.x, -point.y），而在图2中经过移动设备坐标原点后：设备原点为（rect.Width ()/2, rect.Height ()/2），逻辑原点为（0,0）。总结：关于其余映射模式下的移动以及同时采用逻辑坐标原点和谁被坐标原点移动的情况同样可采用上面的分析方法，不过特别注意不同映射模式下的原点移动！////////////////Windows坐标系分为逻辑坐标系和设备坐标系两种，GDI支持这两种坐标系。一般而言， GDI的文本和图形输出函数使用逻辑坐标，而在客户区移动或按下鼠标的鼠标位置是采用设备坐标。 逻辑坐标系是面向DC的坐标系，这种坐标不考虑具体的设备类型，在绘图时，Windows会根据当前设置的映射模式将逻辑坐标转换为设备坐标。 设备坐标系是面向物理设备的坐标系，这种坐标以像素或设备所能表示的最小长度单位为单位，X轴方向向右，Y轴方向向下。设备坐标系的原点位置(0, 0)不限定在设备显示区域的左上角。 设备坐标系分为屏幕坐标系、窗口坐标系和客户区坐标系三种相互独立的坐标系。 屏幕坐标系以屏幕左上角为原点，一些与整个屏幕有关的函数均采用屏幕坐标，如GetCursorPos()、SetCursorPos()、CreateWindow()、MoveWindow()。弹出式菜单使用的也是屏幕坐标。 窗口坐标系以窗口左上角为坐标原点，它包括窗口标题栏、菜单栏和工具栏等范围。 客户区坐标系以窗口客户区左上角为原点，主要用于客户区的绘图输出和窗口消息的处理。鼠标消息的坐标参数使用客户区坐标，CDC类绘图成员函数使用与客户区坐标对应的逻辑坐标。 ,它们在屏幕上用真实的物理像素表示 屏幕坐标 Screen coordinates: 原点(0,0)位于屏幕的左上角窗口坐标 Window coordinates: 原点(0,0)位于窗口的左上角(包括非客户区,如标题条客户区坐标 Client-window coordinates: 原点(0,0)位于客户窗口的左上角逻辑坐标是GDI函数在屏幕上显示数据所用的坐标,逻辑坐标除非与物理坐标相关联,否则没有义.windows依靠映射模式解释逻辑坐标.比如缺省的模式为MM_TEXT,该模式下,物理坐标与逻辑坐标是一对一的关系 编程时，有时需要根据当前的具体情况进行三种设备坐标之间或与逻辑坐标的相互转换。 MFC提供了两个函数CDC::DPtoLP()和CDC:: LPtoDP()用于设备坐标与逻辑坐标之间的相互转换。 MFC提供了两个函数CWnd::ScreenToClient()和CWnd::ClientToScreen()用于屏幕坐标与客户区坐标的相互转换。 映射模式确定了在绘制图形时所依据的坐标系，它定义了逻辑单位的实际大小、坐标增长方向，所有映射模式的坐标原点均在设备输出区域（如客户区或打印区）的左上角。此外，对于某些映射模式，用户还可以自定义窗口的长度和宽度，设置视图区的物理范围。 映射模式使得程序员可不必考虑输出设备的具体设备坐标系，而在一个统一的逻辑坐标系中进行图形的绘制。 （二）坐标模式为了在不同的领域使用逻辑坐标(通过SetMapMode设置)，Windows提供了以下8种坐标模式（见前面介绍）：分别为MM_TEXTMM_HIENGLISHMM_LOENGLISHMM_HIMETRICMM_LOMETRICMM_TWIPSMM_ANISOTROPICMM_ISOTROPIC。（三）实例解析1.建立以左上角为原点，X轴和Y轴为1000的坐标，如下图 我们可以用以下代码：void CTtView::OnDraw(CDC pDC){CTtDoc pDoc = GetDocument();ASSERT_VALID(pDoc);CRect rect;GetClientRect(&amp;rect);pDC-&gt;SetMapMode(MM_ANISOTROPIC);pDC-&gt;SetViewportOrg(0,0);pDC-&gt;SetViewportExt(rect.right,rect.bottom);pDC-&gt;SetWindowOrg(0,0);pDC-&gt;SetWindowExt(1000,1000); //画图pDC-&gt;MoveTo(50,50);pDC-&gt;LineTo(50,950);pDC-&gt;LineTo(950,950);pDC-&gt;LineTo(50,50);}代码分析：1）. GetClientRect(&amp;rect); 取得客户区矩形区域，将其存放在rect中。2）. 用pDC-&gt;SetMapMode(MM_ANISOTROPIC); 设置映射模式。3）. 通过pDC-&gt;SetViewportOrg(0,0); 与pDC-&gt;SetWindowOrg(0,0);设置设备坐标的原点与逻辑坐标的原点。4）. 通过pDC-&gt;SetViewportExt(rect.right,rect.bottom);和pDC-&gt;SetWindowExt(1000,1000);来确定逻辑坐标下和设备坐标下的尺寸对应关系。5）. 在MM_ANISOTROPIC模式下，X轴单位和Y轴单位可以不相同。6）. 坐标方向的确定方法是如果逻辑窗范围和视口范围符号相同，则逻辑坐标的方向和视口的方向相同，即X轴向右为正，Y轴向下为正。7）. 如果将显示模式改为MM_ISOTROPIC，那么X轴单位和Y轴单位一定相同，感兴趣的读者可以自己试一下。2.建立以视窗中心为原点的坐标并画一个三角形，如下图 用如下代码：void CTtView::OnDraw(CDC pDC){CTtDoc pDoc = GetDocument();ASSERT_VALID(pDoc);CRect rect;GetClientRect(&amp;rect);pDC-&gt;SetMapMode(MM_ANISOTROPIC);pDC-&gt;SetViewportOrg(rect.right/2,rect.bottom/2);pDC-&gt;SetViewportExt(rect.right,rect.bottom);pDC-&gt;SetWindowOrg(0,0);pDC-&gt;SetWindowExt(1000,-1000);//画一个三角形pDC-&gt;MoveTo(150,150);pDC-&gt;LineTo(-150,-200);pDC-&gt;LineTo(150,-150);pDC-&gt;LineTo(150,150);}代码分析：1）. 用 pDC-&gt;SetViewportOrg(rect.right/2,rect.bottom/2); 设置视口的原点。2）. 用pDC-&gt;SetViewportExt(rect.right,rect.bottom);和pDC-&gt;SetWindowExt(1000,-1000);来确定设备坐标和逻辑坐标的单位对应关系。3）. 因为逻辑窗范围和视口范围的符号不一致，纵坐标取反，所以Y轴向上为正。8.3.3绘图颜色Windows中的颜色一般用4个字节表示（0BGR（整数序）或RGB0（字节序），因为Intel CPU的低位字节在前），Win32 API中定义了一个专门表示颜色索引值的变量类型COLORREF（windef.h）：typedef DWORD COLORREF; // 0x00bbggrr和一个由红绿蓝三原色构造颜色值的宏RGB（wingdi.h）： #define RGB(r,g,b)((COLORREF)(((BYTE)(r)|((WORD)((BYTE)(g))&lt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[网页CSS按钮]]></title>
    <url>%2F2017%2F09%2F15%2F%E7%BD%91%E9%A1%B5CSS%E6%8C%89%E9%92%AE%E5%B1%95%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[测试 /*头像*/ .imgtest { margin: 10px 5px; overflow: hidden; } .list_ul figcaption p { font-size: 12px; color: #aaa; } .imgtest figure div { display: inline-block; margin: 5px auto; width: 100px; height: 100px; border-radius: 100px; border: 2px solid #fff; overflow: hidden; -webkit-box-shadow: 0 0 3px #ccc; box-shadow: 0 0 3px #ccc; } .imgtest img { width: 100%; min-height: 100%; text-align: center; } /*按钮*/ .button { border: none; color: white; padding: 15px 32px; text-align: center; text-decoration: none; display: inline-block; font-size: 16px; margin: 4px 2px; cursor: pointer; } .button3 { border-radius: 8px; } .button1 { background-color: #f44336; border-radius: 8px; } /* Red */ .button:hover { background-color: #f44336 } .button:active { background-color: f44336; box-shadow: 0 5px #666; transform: translateY(4px); } /*边框*/ .table { /* background-color: #4CAF50; /* Green */ border: none; color: white; padding: 15px 32px; text-align: center; text-decoration: none; display: inline-block; font-size: 16px; margin: 4px 2px; cursor: pointer; -webkit-transition-duration: 0.4s; /* Safari */ transition-duration: 0.4s; } .table:hover { box-shadow: 0 12px 16px 0 rgba(0, 0, 0, 0.24), 0 17px 50px 0 rgba(0, 0, 0, 0.19); } .table1 { width: 100%; background-color: white; color: black; border: 2px solid #e7e7e7; } 修改资料 关于我们 消息中心 收藏兼职 反馈我们 退出登录]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello Music!]]></title>
    <url>%2F2017%2F09%2F14%2Fhello-world%2F</url>
    <content type="text"><![CDATA[今天天气很好，突然想听歌！就这样。]]></content>
  </entry>
</search>

<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="11 Vc++2010开发平台概述    31.1    Vc++2010概述    31.2 Visual Studio 2010 集成开发环境    31.2.1安装Visual Studio 2010    31.2.2配置Visual Studio 2010    31.2.3解决方案和项目    31.2.4生成和调试工具    31.2.5部署工具    31.2.6 Ribbon界面">
<meta property="og:type" content="article">
<meta property="og:title" content="vc++(vs2010) windows编程与绘图程序设计">
<meta property="og:url" content="http://yoursite.com/2017/09/21/vc++(vs2010) windows编程与绘图程序设计/index.html">
<meta property="og:site_name" content="lewyu">
<meta property="og:description" content="11 Vc++2010开发平台概述    31.1    Vc++2010概述    31.2 Visual Studio 2010 集成开发环境    31.2.1安装Visual Studio 2010    31.2.2配置Visual Studio 2010    31.2.3解决方案和项目    31.2.4生成和调试工具    31.2.5部署工具    31.2.6 Ribbon界面">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2017-09-21T15:13:12.172Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="vc++(vs2010) windows编程与绘图程序设计">
<meta name="twitter:description" content="11 Vc++2010开发平台概述    31.1    Vc++2010概述    31.2 Visual Studio 2010 集成开发环境    31.2.1安装Visual Studio 2010    31.2.2配置Visual Studio 2010    31.2.3解决方案和项目    31.2.4生成和调试工具    31.2.5部署工具    31.2.6 Ribbon界面">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/09/21/vc++(vs2010) windows编程与绘图程序设计/"/>





  <title>vc++(vs2010) windows编程与绘图程序设计 | lewyu</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">lewyu</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/21/vc++(vs2010) windows编程与绘图程序设计/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lewyu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lewyu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">vc++(vs2010) windows编程与绘图程序设计</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-21T23:10:58+08:00">
                2017-09-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>11 Vc++2010开发平台概述    3<br>1.1    Vc++2010概述    3<br>1.2 Visual Studio 2010 集成开发环境    3<br>1.2.1安装Visual Studio 2010    3<br>1.2.2配置Visual Studio 2010    3<br>1.2.3解决方案和项目    3<br>1.2.4生成和调试工具    3<br>1.2.5部署工具    3<br>1.2.6 Ribbon界面设计可视化    4<br>2 Visual Studio 2010 MFC基本程序设计    4<br>2.1 MFC应用程序概述    4<br>2.1.1简单的MFC应用程序    4<br>2.1.2 MFC应用程序分析    4<br>2.2 MFC应用程序的创建    4<br>2.2.1 用AppWizard创建CLR控制台应用程序    4<br>2.2.2 用AppWizard创建win32控制台应用程序    4<br>2.2.3 用AppWizard创建一个MFC应用程序    5<br>2.3 MFC的类    9<br>2.3.1 MFC应用程序中包含的类    9<br>2.3.2 应用程序类    10<br>2.3.3 主框架类    10<br>2.3.4 视图类    10<br>2.3.5 文档类    10<br>2.3.6 对话框类    10<br>2.3.7 菜单类    10<br>2.3.8 线程基类    10<br>3 Wndows窗体应用程序    11<br>3.1 创建Wndows窗体应用程序    11<br>3.2 窗体属性及设置    12<br>3.3 窗体事件及处理    13<br>3.4 窗体控件添加与编辑    13<br>4 用户界面设计    13<br>4.1 菜单设计    13<br>4.1.1 菜单的类型    13<br>4.1.2 菜单设计    13<br>4.1.3 创建弹出式菜单    20<br>4.1.4 创建动态菜单    20<br>4.1.5 创建基于对话框的菜单    20<br>4.2 工具栏设计    20<br>4.3 状态栏设计    20<br>5 对话框设计    20<br>5.1 静态对话框    20<br>5.1.1静态对话框的建立过程    20<br>5.1.2静态对话框的应用    21<br>5.2 非静态对话框    31<br>5.3 通用对话框    31<br>6常用控件    31<br>6.1 公共控件    31<br>6.2 容器    31<br>6.3 数据控件    31<br>7 键盘鼠标事件    32<br>7.1键盘事件    32<br>7.2 鼠标事件    42<br>7.2.1客户区鼠标消息    42<br>7.2.2非客户区鼠标消息    45<br>7.2.3实例    46<br>8 图形文本与图像处理    51<br>8.1图形设备接口GDI（Graphics Device Interface）    51<br>8.2 设备上下文DC（device context）    54<br>8.2.1 设备上下文概述    54<br>8.2.2 CDC类    57<br>8.3 绘图环境    60<br>8.3.1绘图环境介绍    60<br>8.3.2映射模式与坐标系    61<br>8.3.3绘图颜色    71<br>8.3.4设置绘图属性    72<br>8.3.6几何对象的结构和类    79<br>8.4 画笔和画刷    85<br>8.4.1画笔    85<br>8.4.2画刷    92<br>8.5 绘图    99<br>8.5.1 绘图步骤    99<br>8.5.2 画像素点    99<br>8.5.3 画线状图    100<br>8.5.4 拖放画动态直线    104<br>8.5.5 画填充图    109<br>8.5.6 清屏    111<br>8.5.7 在控件上绘图    112<br>8.6 文本绘制    115<br>8.7 位图    115<br>8.8 图标和光标    116<br>8.9 图像处理    116<br>9 文件处理    116<br>10 数据库编程    116</p>
<p>1 Vc++2010开发平台概述<br>1.1    Vc++2010概述</p>
<p>1.2 Visual Studio 2010 集成开发环境</p>
<p>1.2.1安装Visual Studio 2010</p>
<p>1.2.2配置Visual Studio 2010</p>
<p>1.2.3解决方案和项目</p>
<p>1.2.4生成和调试工具</p>
<p>1.2.5部署工具</p>
<p>1.2.6 Ribbon界面设计可视化</p>
<p>2 Visual Studio 2010 MFC基本程序设计<br>2.1 MFC应用程序概述</p>
<p>2.1.1简单的MFC应用程序</p>
<p>2.1.2 MFC应用程序分析</p>
<p>2.2 MFC应用程序的创建</p>
<p>2.2.1 用AppWizard创建CLR控制台应用程序</p>
<p>2.2.2 用AppWizard创建win32控制台应用程序</p>
<p>2.2.3 用AppWizard创建一个MFC应用程序<br>1.打开vc++2010，从起始页中选择“新建项目”如图2.2.3.1。</p>
<p>图2.2.3..1<br>弹出图2.2.3.2所示界面，左侧选择“viaual c++语言”，中间选择“MFC 应用程序”，<br>图2.2.3.2<br>名称为huitu，位置为桌面，点击“确定”，弹出图2.2.3.3界面。</p>
<p>图2.2.3`.3<br>然后一路点击下一步（或者直接点击“完成”），则自动生成一个MFC 应用程序，此时查看生成的程序文件夹内包含的文件，如图2.2.3.4</p>
<p>图2.2.3`.4<br>Huitu文件夹内文件如图2.2.3.5</p>
<p>图2.2.3.5</p>
<p>点击启动调试工具拦（绿色三角，图2.2.3.6）或者按F5则系统调试运行，在弹出界面中选择是，弹出图2.2.3.7的程序运行界面。</p>
<p>图2.2.3.6</p>
<p>图2.2.3.7<br>此时再看程序文件夹内的文件如图2.8</p>
<p>图2.2.3.8<br>可以看见多了debug文件夹，分别打开debug文件夹以及huitu文件夹内的debug文件夹看看都多了啥文件。<br>至此，一个文正的MFC应用程序建立完成。保存退出vc++2010，要再次进入刚才建立的应用程序，直接点击程序文件夹内的“huitu.sln”即可。</p>
<p>2.3 MFC的类</p>
<p>2.3.1 MFC应用程序中包含的类</p>
<p>2.3.2 应用程序类</p>
<p>2.3.3 主框架类</p>
<p>2.3.4 视图类</p>
<p>2.3.5 文档类</p>
<p>2.3.6 对话框类</p>
<p>2.3.7 菜单类</p>
<p>2.3.8 线程基类</p>
<p>3 Wndows窗体应用程序<br>3.1 创建Wndows窗体应用程序<br>1.启动vc++2010，如图3.1.1。</p>
<p>图3.1.1<br>2.选择新建项目<br>在打开的窗口中，左侧语言选择vc++，窗口中间选择“windows窗体应用程序”，窗口下面“名称”填写form，工程位置为桌面（图3.1.2），点击确定，建成的应用程序界面如图3.1.3。</p>
<p>图3.1.2</p>
<p>图3.1.3<br>3.2 窗体属性及设置</p>
<p>3.3 窗体事件及处理</p>
<p>3.4 窗体控件添加与编辑</p>
<p>4 用户界面设计<br>4.1 菜单设计<br>4.1.1 菜单的类型</p>
<p>4.1.2 菜单设计<br>建立菜单的过程如下：<br>1.打开工程。打开前面建立的工程绘图（双击huitu工程文件夹中的huitu.sln）。<br>2.打开资源视图。通过“视图-其他窗口-资源视图”菜单打开资源视图窗口，如图4.1.2.1，在vc++界面左侧显示资源视图窗口。</p>
<p>图4.1.2.1<br>3.添加菜单。点击资源视图的menu，展开如图4.1.2.2所示</p>
<p>图4.1.2.2<br>可以看到在工程中有多个菜单，其中IDR_huituTYPE菜单是显示在各子文档界面中的菜单；IDR_MAINFRAME建立的菜单是程序主框架中显示的菜单（把所有子文档关闭后会显示）；<br>在此双击IDR_huituTYPE，打开窗口如图4.1.2.3所示。</p>
<p>图4.1.2.3<br>在请在此处键入位置点击，光标激活后输入“直线”，同时会在文本框右边和下面分别出现写有“请在此键入”字样的文本框，右边的代表键入的直线菜单的子菜单，下面代表直线菜单同级的菜单，其他以此类推，选择直线菜单后，查看vc++界面中右下角的属性面板，可以看到“popup”属性设置的是“true”，代表直线菜单是弹出式菜单，它下面还有下一级菜单，否则，该属性如果设置为“false”，则它不能再添加子菜单了。按照以上方法，在直线菜单下设置“直线1”，“直线2”两个子菜单，建立与直线同级的“圆”菜单，其下设置“圆1”，“圆2”两个子菜单，如图4.1.2.4。</p>
<p>图4.1.2.4<br>4.运行查看菜单。按F5或者点击启动调试工具（绿色三角箭头），在探出的窗口中选择是，启动运行后测绘看到建立的菜单（图4.1.2.5）。</p>
<p>图4.1.2.5<br>5.为菜单添加函数并且编写代码<br>    菜单添加后还不能运行，要想让它起作用，需要为其添加函数并在函数里添加代码，为菜单添加函数过程为（以直线1为例）：选择直线1，在属性面板中把ID属性右边的值改为ID_line1,然后通过“项目-类向导”打开类向导窗口（图1.1.2.6）</p>
<p>图4.1.2.6<br>类名处选择huituView，在命令标签列表中找到并点击ID_line1，在消息标签中点击COMMAND，如图4.1.2.7。<br>I</p>
<p>图4.1.2.7<br>再点击“添加处理程序”按钮，弹出添加函数对话框</p>
<p>图4.1.2.8<br>成员函数名称默认（也可以修改），点确定，则与菜单直线1对应的函数生成，此时可通过点击图4.1.2.7中的“编辑代码”进入函数，或者在vc界面右上角的“解决资源管理器”面板中展开源代码（图4.1.2.8），找到huituView.CPP双击该文件也可进入函数。</p>
<p>图4.1.2.8<br>在函数中的// TODO: 在此添加命令处理程序代码<br>下面添加<br>CClientDC dc(this);<br>dc.LineTo(500,500);<br>两句，如图4.1.2.9</p>
<p>图4.1.2.9<br>6.运行检验菜单功能<br>按F5运行程序后点击直线1菜单，可以看到在用户区画出一条直线。<br>4.1.3 创建弹出式菜单</p>
<p>4.1.4 创建动态菜单</p>
<p>4.1.5 创建基于对话框的菜单</p>
<p>4.2 工具栏设计</p>
<p>4.3 状态栏设计</p>
<p>5 对话框设计</p>
<p>5.1 静态对话框<br>5.1.1静态对话框的建立过程<br>建立静态对话框的过程如下：<br>1.打开或建立工程。按照前面方法打开或者建立一个工程（MFC工程或者窗体应用程序均可，此处以mfc工程为例）<br>2.打开资源窗口。通过“视图-其他窗口-资源视图”打开资源视图窗口。<br>3.建立对话框。在资源视图的DIALOG文件夹上单击右键选择insert dialog，弹出新建的对话框，根据需要可以修改对话框属性面板中的属性值。<br>4.添加对话框类。在建立的该对话框上双击鼠标左键，弹出添加类向导，根据提示设置好参数后确认，则建立了与对话框对应的对话框类。<br>5.1.2静态对话框的应用<br>对话框的应用一般是实现人机交互，以下结合huitu工程中的直线2菜单说明对话框的应用，功能为点击直线2菜单，弹出对话框，在对话框里设置好直线的起点与终点坐标并确认后在客户区画出设置的起点到终点的直线。<br>1.打开工程。双击huitu.sln打开工程。<br>2.添加对话框。通过“视图-其他窗口-资源视图”打开资源视图，在资源视图的DIALOG文件夹上单击右键选择insert dialog，弹出新建的对话框（图5.1.2.1），在属性面板中把对话框的ID属性修改为：IDD_line2_dlg。</p>
<p>图5.1.2.1<br>3.建立对话框类。在建立的对话框上双击鼠标左键，弹出建立对话框类向导，名称中输入line2dlg，基类选择CDIalog（图5.1.2.2）,点击完成，完成对话框类的建立，可以看到在解决资源管理器的头文件和源文件中已经建立了相应的件。</p>
<p>图5.1.2.2<br>4.添加控件。<br>在对话框上从工具箱中添加四个静态文本框、四个编辑文本框、一个按钮，静态文本框的caption属性分别改为：起点x坐标，起点y坐标，终点x坐标，终点y坐标，按钮caption属性改为“确定”。如图5.1.2.3.</p>
<p>图5.1.2.3<br>5.为编辑文本框添加变量。<br>要使用文本框，必须为其添加对应的变量，选择第一个文本框，点击“项目-类向导”菜单打开类向导，选择“成员变量”标签（图5.1.2.4），鼠标点击IDC_EDIT1（编辑文本框1对应的ID），点击右边的添加变量按钮弹出添加变量窗口。</p>
<p>图5.1.2.4</p>
<p>图5.1.2.5<br>在变量设置窗口中，成员变量名称输入m_line1x，类别选择value，类型选择long（图5.1.2.5）.点确定。用同样的方法为其他三个编辑框添加变量，结果如图 5.1.2.6所示。</p>
<p>图5.1.2.6<br>6.为按钮添加函数，获取数据。<br>为了点击按钮确定后获取坐标数据以便于画直线，需要为按钮添加函数，选择前面添加的按钮“确定”，通过“项目-类向导”菜单打开类向导，选择命令标签，点击确定按钮的ID（IDC_BUTTON1），点击消息列表中的BN_CLICKED（代表鼠标点击时触发函数或者事件运行），见图5.1.2.7，击添加处理程序，弹出处理程序对话框，默认之后点击确定则为按钮添加了对应的函数，双击line2dlg.cpp会看见添加了如下函数：<br>void line2dlg::OnClickedButton1()<br>{<br>    // TODO: 在此添加控件通知处理程序代码</p>
<p>}</p>
<p>图5.1.2.7<br>7.编写代码获取数据。在前面添加的按钮函数中编写如下代码获取数据：<br>UpdateData(true);<br>CDialog::EndDialog(0); //结束对话框</p>
<p>该函数的作用是把输入文本框的坐标数据赋值到对应的变量中，即四个文本框对应的变量line1x,line1y,line1endx,line1endy。如果代码为<br>UpdateData(false);<br>则是指把变量中的数值显示到变量对应的文本框中。<br>CDialog::EndDialog(0);<br>是为了结束对话框。<br>8.为菜单添加代码，画对话框设置坐标的的直线。<br>点击资源视图中的menu文件夹展开，双击IDR_huituTYPE菜单，选择直线2菜单，把属性中的ID属性改为ID_line2，通过“项目-类向导”打开类向导，类名选择Chuituview,命令标签中的对象选择ID_line2，消息选择COMMAND（图5.1.2.8），点击添加处理程序，弹出窗口中默认确定，则自动打开ChuituView.cpp，并且光标定位到该函数中，代码如下：<br>void ChuituView::OnLine2()<br>{<br>    // TODO: 在此命令处处理程序代码</p>
<p>}</p>
<p>图5.1.2.8<br>定位到该代码窗口的最上端头文件处，添加以下一句：</p>
<p>#include “line2dlg.h”<br>目的是把对话框类包含进来，否则系统不认对话框中的信息。然后再online2()函数中添加如下代码：<br>line2dlg dlg; //生成对话框对象<br>    dlg.DoModal();//显示对话框<br>    CClientDC dc(this);//生成设备环境对象，获取设备环境<br>    dc.MoveTo(dlg.m_line1x,dlg.m_line1y);//定位到起点坐标<br>    dc.LineTo(dlg.m_line1endx,dlg.m_line1endy);//从起点到终点画直线</p>
<p>9.运行程序。编译运行，点击直线2菜单会弹出对话框，在对话框中设置好起点终点坐标后点确定，则在客户区画出指定坐标的直线。<br>5.2 非静态对话框</p>
<p>5.3 通用对话框</p>
<p>6常用控件<br>6.1 公共控件</p>
<p>6.2 容器</p>
<p>6.3 数据控件</p>
<p>7 键盘鼠标事件<br>7.1键盘事件<br>为了使用户掌握键盘消息及其处理消息，介绍一个键盘消息处理实例。<br>1.实例说明<br>   本实例通过工程向导创建一个单文档工程，在其中响应键盘的WM_KEYDOWN、WM_KEYUP、WM_CHAR消息，实现下面的功能：<br>   当用户按下了Shift键，在视图窗口中显示提示信息“用户按下了Shift键”；<br>   当用户释放了Shift键时，在视图窗口中显示提示信息“用户释放了Shift键！”；<br>   当用户按下了Shift键后又按下了字符“B”键，在视图窗口中显示提示信息“用户同时按下了Shift键和B键”（即输入B键或b键）。<br>2.开发过程<br>（1）创建工程。<br>    利用MFC AppWizard[EXE]建立一个单文档的MFC工程“KeyboardDemo”。<br>（2）在ClassView选项卡上用鼠标右键单击该类，并从弹出的快速菜单中选择[Add Member Variable…]<br>   菜单命令，为KeyboardDemoView类添加一个新的成员变量bShiftdown,将此成员变量的类型设置为BOOL，并将其访问权限设置为Private,<br>   单击[OK]按钮，完成成员变量的添加操作。按照同样的方法，再添加2个BOOL型private成员变量bShiftup和bShiftB，<br>   接下来在KeyboardDemoView构造函数中给三个指示变量赋初值”false”。代码如下：<br>           CKeyboardDemoView::CKeyboardDemoView()<br>           {<br>               bShiftdown=bShiftup=bShiftB=false;//赋初值<br>           }<br>（3）利用“建立类向导”添加键盘消息及处理函数，步骤如下：<br>    在”ClassName”列表框中，选择键盘消息的处理函数”CKeyboardDemoView”，在”Object IDs”列表框中选择“CKeyboardDemoView”，<br>    则在“Message”列表框中，列出了MFC为其预定义的消息，分别选择WM_KEYDOWN、WM_KEYUP、WM_CHAR消息，<br>    单击“Add Function”按钮，MFC就会为其自动添加相应的消息映射宏和消息处理函数。<br>（4）添加实现代码：在资源文件“KeyboardDemoView.cpp”中添加各键盘消息函数的实现代码。<br>    OnKeyDown函数的代码如下：<br>           void CKeyboardDemoView::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)<br>           {<br>               if(nChar==VK_SHIFT)//判断Shift键是否被按下<br>               {<br>                   bShiftdown=true;<br>                   bShiftup=false;<br>                   Invalidate(true);  //显示信息<br>               }<br>               CView::OnKeyDown(nChar, nRepCnt, nFlags);<br>           }<br>   注：Invalidate(TRUE)将整个窗口设置为需要重绘的无效区域，它会产生WM_PAINT消息，这样OnDraw将被调用。<br>OnKeyUp函数的代码如下：<br>           void CKeyboardDemoView::OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags)<br>           {<br>               if(nChar==VK_SHIFT)//判断Shift键是否被释放<br>               {<br>                   bShiftup=true;<br>                   bShiftdown=false;<br>                   Invalidate(true);//显示信息<br>               }<br>               CView::OnKeyUp(nChar, nRepCnt, nFlags);<br>           }<br>OnChar函数的代码如下：<br>           void CKeyboardDemoView::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)<br>           {<br>               //判断是否同时敲击了字符键B键和Shift键<br>               if((nChar==’b’)|(nChar==’B’))     //if((nChar==66)|(nChar==98))<br>               {<br>                   if(bShiftdown)<br>                   {<br>                       bShiftB=true;<br>                       bShiftdown=false;<br>                       Invalidate(true);<br>                   }<br>               }<br>               CView::OnChar(nChar, nRepCnt, nFlags);<br>           }<br>在资源文件”KeyboardDemoView.cpp”的OnDraw函数中，实现在客户区窗口输出按键提示信息。代码如下：<br>           void CKeyboardDemoView::OnDraw(CDC* pDC)<br>           {<br>               if(bShiftdown)//按下了Shift键<br>               {<br>                   pDC-&gt;TextOut(20,20,”用户按下了Shift键!”);<br>               }<br>               if(bShiftup)//释放了Shift键<br>               {<br>                   pDC-&gt;TextOut(20,20,”用户释放了Shift键!”);<br>               }<br>               if(bShiftB)//同时按下了Shift键和B键<br>               {<br>                   pDC-&gt;TextOut(20,20,”用户同时按下Shift键和B键!”);<br>                   bShiftB=false;<br>               }<br>           }</p>
<p>举例：<br>CDC<em> pDC =GetDC();<br>    if (nChar==VK_UP)<br>       {<br>        pDC-&gt;Ellipse(40,40,200,200);<br>    }<br>键盘事件总结：<br>Vc++中键盘事件中函数原型如下（以键盘按下为例，其他类似）<br>OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)<br>其中：<br>nChar ：表示按键的字符代码。<br>nRepCnt：表示按键的重复次数。<br>nFlags：表示扫描码、先前键状态、键转换状态等。<br>nChar的取值表：<br>虚拟键码    对应值    对应键<br>VK_LBUTTON    1    鼠标左键<br>VK_RBUTTON    2    鼠标右键<br>VK_CANCEL    3    Cancel<br>VK_MBUTTON    4    鼠标中键<br>VK_XBUTTON1    5<br>VK_XBUTTON2    6<br>VK_BACK    8    Backspace<br>VK_TAB    9    Tab<br>VK_CLEAR    12    Clear<br>VK_RETURN    13    Enter<br>VK_SHIFT    16    Shift<br>VK_CONTROL    17    Ctrl<br>VK_MENU    18    Alt<br>VK_PAUSE    19    Pause<br>VK_CAPITAL    20    Caps Lock<br>VK_KANA    21<br>VK_HANGUL    21<br>VK_JUNJA    23<br>VK_FINAL    24<br>VK_HANJA    25<br>VK_KANJI    25</em><br>VK_ESCAPE    27    Esc<br>VK_CONVERT    28<br>VK_NONCONVERT    29<br>VK_ACCEPT    30<br>VK_MODECHANGE    31<br>VK_SPACE    32    Space<br>VK_PRIOR    33    Page Up<br>VK_NEXT    34    Page Down<br>VK_END    35    End<br>VK_HOME    36    Home<br>VK_LEFT    37    Left Arrow<br>VK_UP    38    Up Arrow<br>VK_RIGHT    39    Right Arrow<br>VK_DOWN    40    Down Arrow<br>VK_SELECT    41    Select<br>VK_PRINT    42    Print<br>VK_EXECUTE    43    Execute<br>VK_SNAPSHOT    44    Snapshot<br>VK_INSERT    45    Insert<br>VK_DELETE    46    Delete<br>VK_HELP    47    Help<br>    48    0<br>    49    1<br>    50    2<br>    51    3<br>    52    4<br>    53    5<br>    54    6<br>    55    7<br>    56    8<br>    57    9<br>    65    A<br>    66    B<br>    67    C<br>    68    D<br>    69    E<br>    70    F<br>    71    G<br>    72    H<br>    73    I<br>    74    J<br>    75    K<br>    76    L<br>    77    M<br>    78    N<br>    79    O<br>    80    P<br>    81    Q<br>    82    R<br>    83    S<br>    84    T<br>    85    U<br>    86    V<br>    87    W<br>    88    X<br>    89    Y<br>    90    Z<br>VK_LWIN    91<br>VK_RWIN    92<br>VK_APPS    93<br>VK_SLEEP    95<br>VK_NUMPAD0    96    小键盘 0<br>VK_NUMPAD1    97    小键盘 1<br>VK_NUMPAD2    98    小键盘 2<br>VK_NUMPAD3    99    小键盘 3<br>VK_NUMPAD4    100    小键盘 4<br>VK_NUMPAD5    101    小键盘 5<br>VK_NUMPAD6    102    小键盘 6<br>VK_NUMPAD7    103    小键盘 7<br>VK_NUMPAD8    104    小键盘 8<br>VK_NUMPAD9    105    小键盘 9<br>VK_MULTIPLY    106    小键盘 *<br>VK_ADD    107    小键盘 +<br>VK_SEPARATOR    108    小键盘 Enter<br>VK_SUBTRACT    109    小键盘 -<br>VK_DECIMAL    110    小键盘 .<br>VK_DIVIDE    111    小键盘 /<br>VK_F1    112    F1<br>VK_F2    113    F2<br>VK_F3    114    F3<br>VK_F4    115    F4<br>VK_F5    116    F5<br>VK_F6    117    F6<br>VK_F7    118    F7<br>VK_F8    119    F8<br>VK_F9    120    F9<br>VK_F10    121    F10<br>VK_F11    122    F11<br>VK_F12    123    F12<br>VK_F13    124<br>VK_F14    125<br>VK_F15    126<br>VK_F16    127<br>VK_F17    128<br>VK_F18    129<br>VK_F19    130<br>VK_F20    131<br>VK_F21    132<br>VK_F22    133<br>VK_F23    134<br>VK_F24    135<br>VK_NUMLOCK    144    Num Lock<br>VK_SCROLL    145    Scroll<br>VK_LSHIFT    160<br>VK_RSHIFT    161<br>VK_LCONTROL    162<br>VK_RCONTROL    163<br>VK_LMENU    164<br>VK_RMENU    165<br>VK_BROWSER_BACK    166<br>VK_BROWSER_FORWARD    167<br>VK_BROWSER_REFRESH    168<br>VK_BROWSER_STOP    169<br>VK_BROWSER_SEARCH    170<br>VK_BROWSER_FAVORITES    171<br>VK_BROWSER_HOME    172<br>VK_VOLUME_MUTE    173    VolumeMute<br>VK_VOLUME_DOWN    174    VolumeDown<br>VK_VOLUME_UP    175    VolumeUp<br>VK_MEDIA_NEXT_TRACK    176<br>VK_MEDIA_PREV_TRACK    177<br>VK_MEDIA_STOP    178<br>VK_MEDIA_PLAY_PAUSE    179<br>VK_LAUNCH_MAIL    180<br>VK_LAUNCH_MEDIA_SELECT    181<br>VK_LAUNCH_APP1    182<br>VK_LAUNCH_APP2    183<br>VK_OEM_1    186    ; :<br>VK_OEM_PLUS    187    = +<br>VK_OEM_COMMA    188<br>VK_OEM<em>MINUS    189    - </em><br>VK_OEM_PERIOD    190<br>VK_OEM_2    191    / ?<br>VK_OEM_3    192    ` ~<br>VK_OEM_4    219    [ {<br>VK_OEM_5    220    \ |<br>VK_OEM_6    221    ] }<br>VK_OEM_7    222    ‘ “<br>VK_OEM_8    223<br>VK_OEM_102    226<br>VK_PACKET    231<br>VK_PROCESSKEY    229<br>VK_ATTN    246<br>VK_CRSEL    247<br>VK_EXSEL    248<br>VK_EREOF    249<br>VK_PLAY    250<br>VK_ZOOM    251<br>VK_NONAME    252<br>VK_PA1    253<br>VK_OEM_CLEAR    254    </p>
<p>7.2 鼠标事件<br>7.2.1客户区鼠标消息<br>当鼠标通过客户区时，就会触发客户区鼠标消息。<br>常用的客户区鼠标消息<br>消息名称    消息说明<br>WM_LBUTTONDBLCLK    鼠标左键被双击<br>WM_LBUTTONDOWN    鼠标左键被按下<br>WM_LBUTTONUP    鼠标左键被释放<br>WM_MBUTTONDBLCLk    鼠标中键被双击<br>WM_MBUTTONDOWN    鼠标中键被按下<br>WM_MBUTTONUP    鼠标中键被释放<br>WM_MOUSEMOVE    鼠标移动穿过客户区域<br>WM_RBUTTONDBLCLK    鼠标右键被双击<br>WM_RBUTTONDOWN    鼠标右键被按下<br>WM_RBUTTONUP    鼠标右键被释放<br>WM_MOUSEWHEEL    在客户区内鼠标滚轮滚动<br>应用程序一般是处理客户区鼠标消息。非客户区鼠标消息可以被Windows本身妥善的处理。<br>   客户区鼠标消息处理函数的一般形式为：<br>       void OnXxxYyy(UINT nFlag, CPoint point);<br>   如WM_LBUTTONDOWN的消息处理函数，其声明如下：<br>       void OnLButtonDown(UINT nFlag, CPoint point);<br>   函数的两个参数说明如下：<br>      point：为CPoint类对象，记录了当前光标的x,y坐标，这个坐标是以相对于窗口客户区左上角的设备坐标而言的。<br>      nFlags：为鼠标动作的条件标志，取值是以下各种取值的组合。各取值含义如下：<br>MK_LBUTTON:    按下了鼠标的左键。<br>MK_MBUTTON:    按下了鼠标的中键。<br>MK_RBUTTON:    按下了鼠标的右键。<br>MK_CONTROL:    按下了键盘上的Ctrl键。<br>MK_SHIFT:    按下了键盘上的Shift键。<br>在实际编程中，常使用nFlags参数与以上可能取值进行位与运算，来判断消息生成时的鼠标键以及Shift以及Ctrl的状态。<br>      如检测Shift键和Ctrl键的状态，如下：<br>           void OnLButtonDown(UINT nFlags,CPoint point)<br>           {<br>               //判断是否Ctrl键和Shift键同时按下<br>               if((nFlags&amp;MK_CONTROL)&amp;&amp;(nFlags&amp;MK_SHIFT))<br>                  ……<br>           }<br>           void CMouseDemoView::OnMouseMove(UINT nFlags, CPoint point)<br>           {<br>                  //移动鼠标时鼠标左键是按下的<br>               if((nFlags&amp;MK_LBUTTON) == MK_LBUTTON)<br>               {<br>                  …<br>               }<br>               …<br>           }<br>鼠标捕捉<br>   如果你的鼠标移出了某个窗口的客户区范围，那么此窗口将不再继续收到客户区鼠标消息。<br>   SetCapture和ReleaseCapture<br>       如果你用SetCapture进行了鼠标捕捉，那么，即使你的鼠标移出了窗口客户区，仍然可以收到客户区鼠标消息，直到调用ReleaseCapture释放鼠标捕捉或在某个窗口上进行点击为止。<br>   注意：<br>       一旦某个窗口捕获了鼠标，其他窗口将无法得到鼠标消息。<br>       因此，当窗口不再需要捕获鼠标消息时，应及时使用ReleaseCapture函数将鼠标释放。</p>
<p>7.2.2非客户区鼠标消息<br>当鼠标通过非客户区时，就会触发非客户区鼠标消息。<br>常见的非客户区鼠标消息<br>消息名称    消息说明<br>WM_NCLBUTTONDBLCLK     鼠标左键被双击<br>WM_NCLBUTTONDOWN    鼠标左键被按下<br>WM_NCLBUTTONUP    鼠标左键被释放<br>WM_NCMBUTTONDBLCLK    鼠标中键被双击<br>WM_NCMBUTTONDOWN    鼠标中键被按下<br>WM_NCMBUTTONUP    鼠标中键被释放<br>WM_NCMOUSEMOVE    鼠标移动穿过客户区域<br>WM_NCRBUTTONDBLCLK    鼠标右键被双击<br>WM_NCRBUTTONDOWN    鼠标右键被按下<br>WM_NCRBUTTONUP    鼠标右键被释放</p>
<p>7.2.3实例<br>1.鼠标消息的处理及鼠标相关的操作。<br>     实例说明：<br>       通过工程向导创建一个单文档工程，在其中响应鼠标的WM_LBUTTONDOWN、WM_LBUTTONUP、WM_MOUSEMOVE消息<br>     实现功能：<br>       当按下鼠标左键并移动鼠标时，在客户区窗口内将绘制鼠标的移动轨迹，同时光标变为“十字”光标或自定义光标。<br>       当按下鼠标左键时，鼠标的移动范围被限制的整个客户区窗口范围时，即鼠标不能移到客户区外。<br>       当释放了鼠标左键后，鼠标恢复原来的活动区域。<br>开发步骤：<br>     (1)创建工程。启动Visual C++,利用MFC APPWizard[EXE]建立一个新的MFC工程，工程名为“MouseDemo”,<br>        在MFC AppWizard Step1的时候选择“Single documents”即基于单文档的MFC工程，之后的步骤使用默认值。<br>     (2)利用“ClassWizard”添加鼠标消息及处理函数：<br>        在”ClassName”列表框中，选择鼠标消息的处理类”CMouseDemoView”，在“Message”列表框中， 列出了MFC预定义的消息，分别选择WM_LBUTTONDOWN、WM_LBUTTONUP、WM_MOUSEMOVE消息，单击“Add Function”按钮，<br>        MFC就会为其自动添加相应的消息映射宏和消息处理函数。<br>     (3)添加实现代码<br>        首先在头文件”MouseDemoView.h”中声明变量startpoint、rcOldClip。<br>        代码如下：<br>           public:<br>                CPoint   startpoint;<br>                RECT rcOldClip;<br>添加WM_LBUTTONDOWN的消息处理代码如下：<br>               void CMouseDemoView::OnLButtonDown(UINT nFlags, CPoint point)<br>               {<br>                     GetClipCursor(&amp;rcOldClip);//获取原鼠标活动的有效区域<br>                     startpoint=point;   //鼠标所在点为起始点<br>                     SetCapture();   //进行鼠标捕捉<br>                     CView::OnLButtonDown(nFlags, point);<br>                }<br>添加WM_LBUTTONUP的消息处理代码如下：<br>               void CMouseDemoView::OnLButtonUp(UINT nFlags, CPoint point)<br>               {<br>                    ClipCursor(&amp;rcOldClip);//恢复原来的鼠标活动区域<br>                    ReleaseCapture();   //释放鼠标捕捉<br>                    CView::OnLButtonUp(nFlags, point);<br>               }<br>添加WM_MOUSEMOVE的消息处理代码如下：<br>                 void CMouseDemoView::OnMouseMove(UINT nFlags, CPoint point)<br>                 {<br>                         CDC * pDC=GetDC(); //获得DC<br>                         HCURSOR cursor; //鼠标光标句柄<br>                         RECT rcClip; //限制矩形区域<br>                         if((nFlags&amp;MK_LBUTTON) == MK_LBUTTON)  //移动鼠标时鼠标左键是按下的<br>                         {<br>                                 GetWindowRect(&amp;rcClip); //获取客户区窗口区域<br>                                 ClipCursor(&amp;rcClip); //将鼠标的移动限制的客户区<br>                                 cursor=AfxGetApp()-&gt;LoadStandardCursor(IDC_CROSS); //载入标准十字光标<br>                                 SetCursor(cursor);   //使用新光标<br>                                 pDC-&gt;MoveTo(startpoint.x,startpoint.y);   //开始画线<br>                                 pDC-&gt;LineTo(point.x,point.y);<br>                                 startpoint=point;<br>                         }<br>                         CView::OnMouseMove(nFlags, point);<br>                 }<br>      (4)编译运行<br>程序解释：<br>       （1）在鼠标消息响应函数中，根据参数nFlags可以判断鼠标的左、右、中键以及键盘上的Shift键和Ctrl键的按下状态。<br>            在本例的OnMouseMove()函数中，就利用nFlags参数判断鼠标左键是否被按下来完成画线功能。<br>       （2）当按下鼠标左键并移动鼠标时，在OnMouseMove()函数中通过调用API函数ClipCursor()将鼠标的活动区域限制在客户区窗口中。<br>            而当鼠标左键释放时，在函数OnLButtonUp()中，通过ClipCursor()将鼠标的活动区域恢复为原来状态。</p>
<p>2.实例2：<br>CDC* pDC =GetDC();<br>    if (nFlags==MK_LBUTTON)<br>       {<br>        pDC-&gt;LineTo(point.x,point.y);<br>    }<br>    CView::OnLButtonDown(nFlags, point);</p>
<p>3.实例3：<br>CDC<em> pDC =GetDC();<br>    CPen pen;<br>    pen.CreatePen(PS_SOLID,5,RGB(255,0,0));<br>    CPen</em> pOldPen=pDC-&gt;SelectObject(&amp;pen);<br>    if (nFlags==MK_LBUTTON)<br>       {<br>        pDC-&gt;MoveTo(400,300);<br>        pDC-&gt;LineTo(point.x,point.y);<br>    }<br>    pDC-&gt;SelectObject(pOldPen);<br>4.实例4：<br>CDC<em> pDC =GetDC();<br>    CPen pen;<br>    pen.CreatePen(PS_SOLID,2,RGB(255</em>rand(),255<em>rand(),255</em>rand()));<br>    CPen<em> pOldPen=pDC-&gt;SelectObject(&amp;pen);<br>    int i;<br>    if (nFlags==MK_LBUTTON)<br>       {<br>        for(i=1;i<50;i++) {="" pdc-="">MoveTo(point.x,point.y);<br>        pDC-&gt;LineTo(400</50;i++)></em>rand(),400<em>rand());<br>        }<br>    }<br>    pDC-&gt;SelectObject(pOldPen);<br>    ReleaseDC(pDC); //释放DC<br>实例5<br>CDC</em> pDC =GetDC();<br>    CPen pen;<br>    pen.CreatePen(PS_SOLID,2,RGB(255<em>rand(),255</em>rand(),255<em>rand()));<br>    CPen</em> pOldPen=pDC-&gt;SelectObject(&amp;pen);<br>    CRect rect(30,40,point.x,point.y);<br>    pDC-&gt;Rectangle(&amp;rect); // 绘制矩形</p>
<pre><code>pDC-&gt;SelectObject(pOldPen);
ReleaseDC(pDC); //释放DC
</code></pre><p>判断是哪一个字符键也可以：<br>Char keychar;<br>Keychar = char(nChar)<br>If (keychar=”a”)<br>…..<br>其中nChar为键盘事件中的一个参数<br>8 图形文本与图像处理<br>8.1图形设备接口GDI（Graphics Device Interface）<br>GDI（Graphics Device Interface，图形设备接口）是Windows操作系统的传统图形子系统，负责与设备无关的图形绘制，Win32 API为应用程序提供了丰富的绘图函数和功能，MFC对它们进行了C++类封装，参见图8-1。<br>Windows应用程序<br>    MFC<br>Win32 API<br>执行程序    用户界面（User）    GDI+<br>        图形子系统（GDI）<br>设备驱动程序    内核（Kernel）    图形驱动程序<br>硬件抽象层（HAL）<br>计算机硬件<br>图8-1  GDI与Windows操作系统（其中彩色部分为操作系统）<br>传统GDI是随Windows 1.0于1985年11月推出的，新式GDI+则是随Windows XP于2001年10月推出的GDI的改进版，增加了α混色、渐变画刷、样条曲线、矩阵变换、图像处理、持久路径等新功能。随Windows Vista及.NET框架3.0微软于2006年11月又推出了基于DirectX和.NET框架的全新图形子系统WPF（Windows Presentation Foundation，视窗显示/展现基础），它统一了桌面和浏览器等客户端应用程序的图形界面，采用XAML声明式编程，将用户界面的设计和编程彻底分离开来，是Windows的下一代GUI显示系统。<br>GDI+是建立在GDI之上的。WPF则是以.NET框架为基础的。<br>在MFC中，CGdiObject类是GDI对象的基类，而CGDIObject则是直接从CObject类派生的抽象基类,通过查阅MSDN我们可以看到，CGdiObject类有六个直接的派生类，GDI对象主要也是这六个，分别是：CBitmap、CBrush、CFont、CPalette、CPen和CRgn。</p>
<p>CRgn为区域（region）类，对应于窗口中的一个矩形、多边形或（椭）圆区域，可用于移动、拷贝、合并、判断和裁剪。<br>GDI负责系统与用户或者绘图程序之间的信息交换，并控制在输出设备上显示图形或文字。<br>将GDI对象用SelectObject函数选入DC后，就可利用对应的绘图工具进行图形绘制。<br>可用CDC类的多态成员函数SelectObject，将绘图工具对象选入DC，以供绘图时使用：<br>CPen<em> SelectObject( CPen</em> pPen );<br>CBrush<em> SelectObject( CBrush</em> pBrush );<br>virtual CFont<em> SelectObject( CFont</em> pFont );<br>CBitmap<em> SelectObject( CBitmap</em> pBitmap );<br>int SelectObject( CRgn<em> pRgn );<br>CGdiObject</em> SelectObject( CGdiObject* pObject );</p>
<p>8.2 设备上下文DC（device context）<br>8.2.1 设备上下文概述<br>在GDI中，DC(Device context)是一个非常重要的概念。<br>有的书中，将DC翻译为设备描述表（《Windows 程序设计 第五版》作者Charles Petzold），也有的书将DC翻译为设备上下文。<br>到底什么是DC？<br>用现实中的例子来理解可能更容易些。<br>如果你喜欢画画，你得先准备了画布，画笔，颜料……<br>画画的环境搭建好了，你就可以画画了。<br>这个画画的环境，就是DC。<br>在图形环境下，一切都是画出来的，所以，你要准备好一个DC，才能在屏幕上画画。——写字也是画画。<br>在画画的环境中，有哪些对象呢？<br>画布——GDI对象之一：区域<br>画笔——GDI对象之一：画笔<br>颜料盒——GDI对象之一：调色板<br>如果要在画笔上写字的话，写什么样的字体呢？方正字体？—字体也是GDI对象之一。<br>有的画笔比较粗，专用来刷大面积背景色的，这是刷子——GDI对象之一：刷子<br>如果你不想画了，只想把别人画好的画，贴到你的画布上，这也是可以的。——GDI对象之一：位图。<br>所以，这里就有6种GDI对象可以用于DC。<br>现在开始画画了，你拿起了一只笔。——在Windows环境里，这叫选择了一个画笔对象：使用SelectOBject函数。当然，如果你没带笔也没关系，Windows为你准备了几只画笔，你可以这样申请系统提供的缺省画笔：hPen = GetStockObject(WHITE_PEN);<br>如果你画着画着，觉得手中的笔用着不爽，可以换一只啊，没关系的。——依旧是SelectObject()换笔。<br>当然，如果你走出了画室，别完了把你的画笔清除掉，要不画室里全是笔啊，刷子啊，太乱了。——DeleteObject()<br>所以对DC可以这样理解:<br>每一笔用GDI画的都通过它与设备交流最终画在屏幕上不同屏幕/设备它不同,所以可以保证画出的效果相同,增加程序的可移植性也就是GDI是画在DC上的,DC再显示在屏幕上DC为GDI基础通过GDI绘制出来时看不到的也就是不显示的,只在内存上的一副图片,这幅图可以通过DC绘制在设备上有几种常见环境:<br>1）显示设备环境<br>主要用于显示设备上的绘制操作，当应用绘制客户区时，它需要调用BeginPaint、GetDC或GetDCEx函数获取显示设备上下文。绘制结束后，需要调用EndPaint或ReleaseDC函数释放它。<br>2）打印机设备环境<br>应用程序以合适的参数（如打印机驱动名、打印机名等）调用函数CreateDC，完成打印任务后，就会调用DeleteDC，以删除打印机设备上下文。<br>3）内存设备环境<br>主要为特定的设备存储位图，它支持在位图上进行绘制操作。通常通过调用CreateCompatibleDC来获取内存设备上下文，当系统处理这个调用时，它将在内存中创建一个和原始设备颜色格式兼容的位图。<br>内存设备上下文将系统内存用作显示表面，通常使用内存设备上下文预先在系统内存中绘制复杂的图形，然后再快速地将其复制到实际的设备上下文的显示表面上，而绘制图形的结果仍保存在内存设备上下文的DDB中。<br>4）信息设备环境<br>主要用于获取默认设备的数据。如调用函数CreateIC，以便为打印机的特定模型创建信息设备上下文，然后调用函数GetCurrentObject和GetObject来获取默认的画笔和画刷的属性。在使用完信息设备上下文之后，需调用DeleteDC以删除设备上下文。<br>设备描述表（DC）是Windows中的一种数据结构，它包含GDI需要的所有关于显示界面情况的描述字段，包括相连的物理设备和各种各样的状态信息。在Windows画图之前，Windows程序从GDI获取设备描述表句柄（HDC）,并在每次调用完GDI输出函数后将句柄返回给GDI。<br>GDI函数中使用该句柄的数据信息来在设备上下文环境中绘图DC好比画图用的画纸，GDI就是画图时用的工具。<br>在Windows中，绘图包括绘制图形、显示位图和输出文字，它们都需要使用绘图环境DC（Device-Context, 设备上下文）。MFC将DC结构和所有的绘图函数、绘图对象的访问函数、绘图模式与参数的设置函数都封装到了CDC类中。<br>8.2.2 CDC类<br>CDC类是MFC对DC结构及其相关绘图和状态设置函数的C++类封装。CDC是CObject的直接派生类，CDC类自己也有若干派生类，其中包括：窗口客户区DC所对应的CClientDC类、OnPaint和OnDraw消息响应函数的输入参数中使用的CPaintDC类、图元文件对应的CMetaFileDC类和整个窗口所对应的CWindowDC类，参见图8-3。在普通的MFC绘图中，一般直接使用CDC类即可。</p>
<p>CDC类<br>CDC类中有许多成员函数，可以用来设置各种绘图环境、属性和参数，以及绘制各种图形和图像等，将在后面陆续加以介绍。<br>1．获得DC<br>在OnDraw函数中应该使用输入参数pDC，在其他函数中则可调用从CWnd类继承的成员函数GetDC来获得当前窗口（如客户区/视图类）DC的指针，该函数的原型为：<br>CDC<em> GetDC( );<br>注意，每次从OnDraw函数的输入参数或调用GetDC所获得的DC，都是一个全新的临时默认DC，具有默认的绘图环境和设置。它不能用类变量来长期保存，而且原来选入的各种GDI对象全都被作废、原来设置的各种状态也失效，一切都必须从头再来。<br>2．释放DC<br>因为Windows限制可用DC的数量，所以DC属于稀缺的公用资源。因此，对每次获得的DC，在使用完成后必须立即释放。<br>从OnDraw函数的输入参数pDC获得的DC，在该函数运行结束后，系统会自动释放。但由GetDC所获得的DC，则必须自己来手工释放，这可以通过调用从CWnd类继承的成员函数ReleaseDC来完成。该函数的原型为：<br>int ReleaseDC( CDC</em> pDC ); // 成功返回非0<br>例如：<br>void CDrawView::OnLButtonUp(UINT nFlags, CPoint point)<br>{<br>    CDC<em> pDC = GetDC(); // 获取DC<br>    pDC-&gt;SelectObject(&amp;pen); // 选入笔<br>    pDC-&gt;Rectangle(&amp;rect); // 绘制矩形<br>    ReleaseDC(pDC); // 释放DC<br>    CView::OnLButtonUp(nFlags, point);<br>}<br>3．安全DC句柄<br>可以用CDC类的成员函数GetSafeHdc来获取DC所对应窗口（如客户区）的安全DC句柄，该函数的原型为：<br>HDC GetSafeHdc();<br>与用GetDC函数所得到的临时DC不同，该安全DC句柄在窗口的存在期间内一直是有效的。例如，可先定义类变量HDC m_hDC;，再在适当的地方给它赋值m_hDC = GetDC()-&gt;GetSafeHdc();，然后就可以放心地使用了。还可以使用CDC类的成员函数Attach来将一空CDC对象与此安全DC句柄连接在一起，该函数的原型为：<br>BOOL Attach(HDC hDC); // 成功返回非0<br>4．屏幕DC<br>可以以NULL为输入参数，调用全局的API函数GetDC：<br>HDC GetDC(HWND hWnd);<br>来可获取屏幕DC的句柄。例如：<br>HDC hdc = ::GetDC(NULL); // 获取屏幕DC的句柄<br>Ellipse(hdc, 0, 0, 150, 100); // 用API函数在屏幕左上角画一椭圆<br>也可以利用CDC类的成员函数Attach，将屏幕DC的句柄选入自定义的CDC类中，来 构造屏幕CDC类的对象。例如：<br>    HDC hdc = ::GetDC(NULL); // 获取屏幕DC的句柄<br>    CDC sDC; // 定义屏幕DC（空）对象<br>    sDC.Attach(hdc); // 粘上屏幕DC句柄<br>    sDC.Ellipse(0, 0, 150, 100); // 在屏幕左上角画一椭圆<br>8.3 绘图环境<br>8.3.1绘图环境介绍<br>在Windows中，绘图一般在框架窗口的客户区（对应于视图类C</em>View）进行，使用的是封装在MFC的设备上下文（Device-Context，DC）类CDC中的各种绘图函数。<br>在绘图前，一般需先得到客户区大小和CDC对象、设置绘图颜色，然后再根据文档数据或用户操作来绘制各种图形。当然，如果没有特殊要求，最简单的就是直接生成CDC对象，通过对象调用画图函数画图，只是此时颜色是默认黑色，线宽为一个像素的实线图。<br>8.3.2映射模式与坐标系<br>在Windows中，绘图一般在视图窗口的客户区进行，使用的是设备上下文类CDC中各种绘图函数。为了达到理想的绘图效果，有时需要先利用CDC类设置绘图所用的坐标系（映射模式）和各种绘图属性。<br>在Windows中，绘图都是在当前的映射模式（map mode）下（坐标系中）进行的。而当前映射模式可以用CDC类的成员函数SetMapMode来设置。<br>一、默认映射模式<br>映射模式影响所有的图形和文本绘制函数，它定义（将逻辑单位转换为设备单位所使用的）度量单位和坐标方向，Windows总是用逻辑单位来绘图。<br>默认情况下，绘图的默认映射模式为MM_TEXT，其绘图单位为像素（只要不打印输出，屏幕绘图使用该模式就够了）。若窗口客户区的宽和高分别为w和h像素，则其x坐标是从左到右，范围为0 ~ w-1；y坐标是从上到下，范围为0 ~ h-1，参见图8-7。</p>
<p>图8-7  默认的MM_TEXT 图8-8  非自定义且非MM_TEXT映射<br>映射模式下的窗口坐标系            模式下的（初始）窗口坐标系<br>（注意y在当前窗口中的坐标值为负）<br>二、设置映射模式（坐标模式）<br>可使用CDC类的成员函数GetMapMode和SetMapMode来获得和设置当前映射模式：<br>int GetMapMode( ) const; // 返回当前的映射模式<br>virtual int SetMapMode( int nMapMode ); // 返回先前的映射模式<br>映射模式nMapMode的取值见表8-7。<br>表8-7  映射模式的nMapMode取值与含义<br>符号常量    数值    x方向    y方向    逻辑单位<br>MM_TEXT    1    向右    向下    像素<br>MM_LOMETRIC    2    向右    向上    0.1 mm<br>MM_HIMETRIC    3    向右    向上    0.01 mm<br>MM_LOENGLISH    4    向右    向上    0.01 in<br>MM_HIENGLISH    5    向右    向上    0.001 in<br>MM_TWIPS    6    向右    向上    1/1440 in<br>MM_ISOTROPIC    7    自定义    自定义    自定义<br>MM_ANISOTROPIC    8    自定义    自定义    自定义<br>其中，in为英寸，1 in = 2.54 cm；twips（缇）是一种打印标准单位；isotropic（各向同性的），指x与y方向的单位相同；和anisotropic（各向异性的），则是指x与y方向的单位可不同。<br>可见，除了两种自定义映射模式外，x方向都是向右，y方向也只有MM_TEXT的向下，其余的都是向上，与数学上坐标系一致，参见图8-8。除了MM_ANISOTROPIC外，其他所有映射模式的x与y方向的单位都是相同的。所有映射模式的逻辑坐标的原点（0, 0）最初都是在窗口的左上角，但在CScrollView的派生类中，MFC会随用户滚动文档而自动调整逻辑原点的相对位置（改变视点的原点属性）。<br>三、单位转换<br>对所有非MM_TEXT映射模式，有如下重要规则：<br>    CDC的成员函数（如各种绘图函数）具有逻辑坐标参数。<br>    CWnd的成员函数（如各种响应函数）具有设备坐标参数（如鼠标位置point）。<br>    位置的测试操作（如CRect的PtInRect函数）只有使用设备坐标时才有效。<br>    长期使用的值应该用逻辑坐标保存（如窗口滚动后保存的设备坐标就无效了）。<br>因此，为了使应用程序能够正确工作，除MM_TEXT映射模式外，其他映射模式都需要进行单位转换。Windows的GDI负责逻辑坐标和设备坐标之间的转换，这可以调用CDC类的成员函数LPtoDP和DPtoLP来进行：<br>void LPtoDP( LPPOINT lpPoints, int nCount = 1 ) const;<br>void LPtoDP( LPRECT lpRect ) const;<br>void LPtoDP( LPSIZE lpSize ) const;<br>void DPtoLP( LPPOINT lpPoints, int nCount = 1 ) const;<br>void DPtoLP( LPRECT lpRect ) const;<br>void DPtoLP( LPSIZE lpSize ) const;<br>例如：<br>void CDrawView::OnLButtonDown(UINT nFlags, CPoint point) {<br>        CRect rect = m_rect; // 逻辑坐标<br>        CClientDC dc(this);<br>        dc.SetMapMode(MM_LOENGLISH);<br>        dc.LPtoDP(rect); // 转化成设备坐标<br>    // 位置的测试操作只有在使用设备坐标时才有效<br>    if (rect.PtInRect(point)) ……<br>}<br>void CDrawView:: OnMouseMove (UINT nFlags, CPoint point) {<br>    float t,y;<br>    char buf[40];<br>    CDC<em> pDC = GetDC();<br>    pDC-&gt;SetMapMode(MM_HIMETRIC);<br>    pDC-&gt;DPtoLP(&amp;point); // 转化成逻辑坐标<br>    t = t1 + (point.x </em> dt) / w;  sprintf(buf, “%.4fs”, t);<br>    pSB-&gt;SetPaneText(xV, buf);<br>    y = (y0 - point.y) / dy;  sprintf(buf, “%.4f”, y);<br>    pSB-&gt;SetPaneText(yV, buf);<br>    ……<br>}<br>四、建立自己需要的坐标系<br>建立一个合适的坐标系可以为我们的绘图带来很大的方便。下面介绍一下如何在VC中建立我们想要的坐标系。<br>(一)设备坐标和逻辑坐标<br>设备坐标（Device Coordinate）又称为物理坐标（Physical Coordinate），是指输出设备上的坐标。通常将屏幕上的设备坐标称为屏幕坐标。设备坐标用对象距离窗口左上角的水平距离和垂直距离来指定对象的位置，是以像素为单位来表示的，设备坐标的X轴向右为正，Y轴向下为正，坐标原点位于窗口的左上角。<br>逻辑坐标（Logical Coordinate）是系统用作记录的坐标。在缺省的模式（MM_TEXT）下，逻辑坐标的方向和单位与设备坐标的方向和单位相同，也是以像素为单位来表示的，X轴向右为正，Y轴向下为正，坐标原点位于窗口的左上角。逻辑坐标和设备坐标即使在缺省模式下其数值也未必一致，除了在以下两种情况下：</p>
<ol>
<li>窗口为非滚动窗口</li>
<li>窗口为滚动窗口，但垂直滚动条位于滚动边框的最上端，水平滚动条位于最左端，但如果移动了滚动条这两种坐标就不一致了。<br>在VC中鼠标坐标的坐标位置用设备坐标表示，但所有GDI绘图都用逻辑坐标表示，所以用鼠标绘图时，那么必须将设备坐标转换为逻辑坐标，可以使用CDC 函数DptoLP（）将设备坐标转化为逻辑坐标，同样可以用LptoDP（）将逻辑坐标转化为设备坐标。<br>///////////////////<br>MFC逻辑坐标原点与设备坐标原点的移动<br>①原点概念的理解：在数学中常称点（0，0）为坐标原点，但是在windows中原点是一个坐标，但并未必是（0，0）点。原点这个说法的使用时为了联系设备坐标和逻辑坐标—设备坐标的原点一定要和逻辑坐标的原点重合。<br>②映射模式被定义为从窗口（window也即逻辑坐标）到视口（viewport也即设备坐标）的映射，具体的内容可以参考：《MFC Windows 程序设计》P36和《Windows程序设计》P147。<br>③既然用坐标来标注设备坐标系和逻辑坐标系的原点，那么二者坐标值的求取必须具有同一个参考对象，也就是说必须有一个参考点来确定设备坐标中原点和逻辑坐标中的原点的坐标。在windows中选择设备坐标点（0，0）为参考点，设备坐标点（0，0）始终都位于客户区的左上角。（《Windows程序设计》P147）<br>④传送给CDC输出函数的是逻辑坐标，《MFC Windows 程序设计》P36<br>⑤逻辑坐标：可理解成几何作业本上的直角坐标系，坐标值是无限的，Windows的绘图是以逻辑坐标作为参数，也就是说Windows绘图是在逻辑平面上进行的。<br>设备坐标：是物理的，就理解成手上拿着的方形框框（如显示器），通过该方框可以看到在逻辑平面上所画的东西。设备坐标的左上角永远是（0，0）点，且X轴的正方向向右，Y轴的正方向向下。设备总是有尺寸的，只能显示某个范围的内容。<br>默认情况下，逻辑坐标采用MM_TEXT映射模式，该映射模式下逻辑坐标的方向与设备坐标系的方向相同：X轴的正方向向右，Y轴的正方向向下。再加上坐标原点重合，故给人的感觉是只有一个坐标系，具体如图1所示：</li>
</ol>
<p>图1<br>⑥举例说明SetWindowOrg和SetViewportOrg的使用<br>在默认的情况下逻辑坐标到设备坐标的映射模式为：MM_TEXT，为方便起见这里不再更改映射模式，在默认的情况下：窗口原点为（0，0）点，视口原点也为（0，0）点。<br>假设将设备原点移到窗口的中心点，即现有的视口原点不再是（0，0）而是窗口中心点。<br>设dc为一个设备描述表对象，具体实现如下：<br>CRect rect;<br>GetClientRect (&amp;rect);//返回的是设备坐标，而SetViewportOrg需要的也是设备坐标，故此处不用转换<br>dc.SetViewportOrg (rect.Width ()/2, rect.Height ()/2);<br>图解分析如图2所示：<br> 图2<br>具体分析：Ⅰ：将视口原点由（0，0）点移至（x,y）等价于把逻辑点（0，0）映射成设备点（x,y）。<br>Ⅱ：设备坐标原点与逻辑坐标原点必须重合。<br>Ⅲ：默认情况下逻辑坐标的原点为（0,0）点，且本处只移动了设备坐标原点，并没有移动逻辑坐标原点，故逻辑坐标的原点仍为（0,0）点，不过要满足Ⅱ中的条件，逻辑坐标系发生了移动，移动结果如图2所示，此时移动后的设备原点（rect.Width ()/2, rect.Height ()/2）与逻辑原点（0,0）重合。<br>⑦在上面的⑥中将视口原点移到视口的中点，并完成了将逻辑原点到视口中点的映射。为达到相同的效果，用<br>SetWindowOrg移动逻辑坐标原点也可以达到相同的效果。<br>为使理解更加清晰透彻，这里做了两组对比的实验<br>实验一：<br>  CRect rect;<br>  GetClientRect (&amp;rect);<br>  CPoint point (rect.Width () / 2, rect.Height () / 2);<br>  dc.DPtoLP (&amp;point);<br>  dc.SetWindowOrg (point.x, point.y);<br>该实验的逻辑坐标原点移动的示意图如图3所示：<br> 图3<br>在图3中若进行正常移动则逻辑原点将移至设备坐标系的中点，为保证逻辑原点与设备原点的重合，必须移动设备原点（注：由于设备原点没有移动，仍是（0,0）点），但是根据规定设备坐标点是不能移动的，由前面的③可知，作为参考点的设备点（0,0）是不能移动的，不过此处设备点（0,0）恰好又是设备原点而已，故不能移动。既然设备原点不能移动，却又要满足逻辑坐标原点（point.x, point.y）与设备坐标原点（0,0）的重合，只能进行等价移动逻辑坐标系，移动如图3所示：很明显逻辑坐标原点为（point.x, point.y）且满足改点与设备坐标原点（0,0）的重合。不过对比图2，很明显通过对设备坐标原点进行该种移动不能达到相同的效果，即实验一并未得到与⑥中同样的结果。<br>实验二：<br>  CRect rect;<br>  GetClientRect (&amp;rect);<br>  CPoint point (rect.Width () / 2, rect.Height () / 2);<br>  dc.DPtoLP (&amp;point);<br>  dc.SetWindowOrg (-point.x, -point.y);<br>该实验的逻辑坐标原点移动的示意图如图4所示：<br> 图4<br>具体的分析与实验一类似，这里不再赘述了，与图2对比很明显得到：对逻辑坐标原点进行这种移动可达到与移动设备坐标原点相同的效果，但有一点值得注意：达到的效果相同，但进行这种移动后设备坐标原点为（0,0）,逻辑坐标原点为（-point.x, -point.y），而在图2中经过移动设备坐标原点后：设备原点为（rect.Width ()/2, rect.Height ()/2），逻辑原点为（0,0）。<br>总结：关于其余映射模式下的移动以及同时采用逻辑坐标原点和谁被坐标原点移动的情况同样可采用上面的分析方法，不过特别注意不同映射模式下的原点移动！<br>////////////////<br>Windows坐标系分为逻辑坐标系和设备坐标系两种，GDI支持这两种坐标系。一般而言，</p>
<p>GDI的文本和图形输出函数使用逻辑坐标，而在客户区移动或按下鼠标的鼠标位置是采用设备坐标。</p>
<p><1>逻辑坐标系是面向DC的坐标系，这种坐标不考虑具体的设备类型，在绘图时，Windows会根据当前设置的映射模式将逻辑坐标转换为设备坐标。</1></p>
<p><2>设备坐标系是面向物理设备的坐标系，这种坐标以像素或设备所能表示的最小长度单位为单位，X轴方向向右，Y轴方向向下。设备坐标系的原点位置(0, 0)不限定在设备显示区域的左上角。</2></p>
<p>设备坐标系分为屏幕坐标系、窗口坐标系和客户区坐标系三种相互独立的坐标系。</p>
<pre><code>  屏幕坐标系以屏幕左上角为原点，一些与整个屏幕有关的函数均采用屏幕坐标，如GetCursorPos()、SetCursorPos()、CreateWindow()、MoveWindow()。弹出式菜单使用的也是屏幕坐标。

  窗口坐标系以窗口左上角为坐标原点，它包括窗口标题栏、菜单栏和工具栏等范围。

 客户区坐标系以窗口客户区左上角为原点，主要用于客户区的绘图输出和窗口消息的处理。鼠标消息的坐标参数使用客户区坐标，CDC类绘图成员函数使用与客户区坐标对应的逻辑坐标。

,它们在屏幕上用真实的物理像素表示

 屏幕坐标 Screen   coordinates:   原点(0,0)位于屏幕的左上角窗口坐标 Window   coordinates:   原点(0,0)位于窗口的左上角(包括非客户区,如标题条客户区坐标 Client-window   coordinates:   原点(0,0)位于客户窗口的左上角逻辑坐标是GDI函数在屏幕上显示数据所用的坐标,逻辑坐标除非与物理坐标相关联,否则没有义.windows依靠映射模式解释逻辑坐标.比如缺省的模式为MM_TEXT,该模式下,物理坐标与逻辑坐标是一对一的关系

   编程时，有时需要根据当前的具体情况进行三种设备坐标之间或与逻辑坐标的相互转换。

   MFC提供了两个函数CDC::DPtoLP()和CDC:: LPtoDP()用于设备坐标与逻辑坐标之间的相互转换。

   MFC提供了两个函数CWnd::ScreenToClient()和CWnd::ClientToScreen()用于屏幕坐标与客户区坐标的相互转换。

   映射模式确定了在绘制图形时所依据的坐标系，它定义了逻辑单位的实际大小、坐标增长方向，所有映射模式的坐标原点均在设备输出区域（如客户区或打印区）的左上角。此外，对于某些映射模式，用户还可以自定义窗口的长度和宽度，设置视图区的物理范围。

   映射模式使得程序员可不必考虑输出设备的具体设备坐标系，而在一个统一的逻辑坐标系中进行图形的绘制。
</code></pre><p>（二）坐标模式<br>为了在不同的领域使用逻辑坐标(通过SetMapMode设置)，Windows提供了以下8种坐标模式（见前面介绍）：<br>分别为<br>MM_TEXT<br>MM_HIENGLISH<br>MM_LOENGLISH<br>MM_HIMETRIC<br>MM_LOMETRIC<br>MM_TWIPS<br>MM_ANISOTROPIC<br>MM_ISOTROPIC。<br>（三）实例解析<br>1.建立以左上角为原点，X轴和Y轴为1000的坐标，如下图</p>
<p>我们可以用以下代码：<br>void CTtView::OnDraw(CDC<em> pDC)<br>{<br>CTtDoc</em> pDoc = GetDocument();<br>ASSERT_VALID(pDoc);<br>CRect rect;<br>GetClientRect(&amp;rect);<br>pDC-&gt;SetMapMode(MM_ANISOTROPIC);<br>pDC-&gt;SetViewportOrg(0,0);<br>pDC-&gt;SetViewportExt(rect.right,rect.bottom);<br>pDC-&gt;SetWindowOrg(0,0);<br>pDC-&gt;SetWindowExt(1000,1000);<br>        //画图<br>pDC-&gt;MoveTo(50,50);<br>pDC-&gt;LineTo(50,950);<br>pDC-&gt;LineTo(950,950);<br>pDC-&gt;LineTo(50,50);<br>}<br>代码分析：<br>1）. GetClientRect(&amp;rect); 取得客户区矩形区域，将其存放在rect中。<br>2）. 用pDC-&gt;SetMapMode(MM_ANISOTROPIC); 设置映射模式。<br>3）. 通过pDC-&gt;SetViewportOrg(0,0); 与pDC-&gt;SetWindowOrg(0,0);设置设备坐标的原点与逻辑坐标的原点。<br>4）. 通过pDC-&gt;SetViewportExt(rect.right,rect.bottom);和<br>pDC-&gt;SetWindowExt(1000,1000);来确定逻辑坐标下和设备坐标下的尺寸对应关系。<br>5）. 在MM_ANISOTROPIC模式下，X轴单位和Y轴单位可以不相同。<br>6）. 坐标方向的确定方法是如果逻辑窗范围和视口范围符号相同，则逻辑坐标的方向和视口的方向相同，即X轴向右为正，Y轴向下为正。<br>7）. 如果将显示模式改为MM_ISOTROPIC，那么X轴单位和Y轴单位一定相同，感兴趣的读者可以自己试一下。<br>2.建立以视窗中心为原点的坐标并画一个三角形，如下图</p>
<p>用如下代码：<br>void CTtView::OnDraw(CDC<em> pDC)<br>{<br>CTtDoc</em> pDoc = GetDocument();<br>ASSERT_VALID(pDoc);<br>CRect rect;<br>GetClientRect(&amp;rect);<br>pDC-&gt;SetMapMode(MM_ANISOTROPIC);<br>pDC-&gt;SetViewportOrg(rect.right/2,rect.bottom/2);<br>pDC-&gt;SetViewportExt(rect.right,rect.bottom);<br>pDC-&gt;SetWindowOrg(0,0);<br>pDC-&gt;SetWindowExt(1000,-1000);<br>//画一个三角形<br>pDC-&gt;MoveTo(150,150);<br>pDC-&gt;LineTo(-150,-200);<br>pDC-&gt;LineTo(150,-150);<br>pDC-&gt;LineTo(150,150);<br>}<br>代码分析：<br>1）. 用 pDC-&gt;SetViewportOrg(rect.right/2,rect.bottom/2); 设置视口的原点。<br>2）. 用pDC-&gt;SetViewportExt(rect.right,rect.bottom);和pDC-&gt;SetWindowExt(1000,-1000);来确定设备坐标和逻辑坐标的单位对应关系。<br>3）. 因为逻辑窗范围和视口范围的符号不一致，纵坐标取反，所以Y轴向上为正。<br>8.3.3绘图颜色<br>Windows中的颜色一般用4个字节表示（0BGR（整数序）或RGB0（字节序），因为Intel CPU的低位字节在前），Win32 API中定义了一个专门表示颜色索引值的变量类型COLORREF（windef.h）：<br>typedef DWORD COLORREF; // 0x00bbggrr<br>和一个由红绿蓝三原色构造颜色值的宏RGB（wingdi.h）：</p>
<p>#define RGB(r,g,b)<br>((COLORREF)(((BYTE)(r)|((WORD)((BYTE)(g))&lt;<8))|(((dword)(byte)(b))<<16))) 1="" 2="" 3="" 4="" 5="" 6="" 7="" 8="" 9="" 10="" 11="" 12="" 13="" 14="" 15="" 16="" 其中，r、g、b为字节变量，分部对应于红、绿、蓝三原色，取值范围为0~255。rgb宏所对应的函数说明为：="" colorref="" rgb(="" byte="" bred,="" bgreen,="" bblue="" );="" 例如：="" red,="" gray;="" red="RGB(255," 0,="" 0);="" gray="RGB(128," 128,128);="" 在api中还定义了由colorref变量获取各个颜色分量的宏getxvalue（wingdi.h），它们对应的函数说明为（其中的dword="" rgb="" 等价于="" col）：="" getrvalue(dword="" rgb);="" getgvalue(dword="" getbvalue(dword="" 8.3.4设置绘图属性="" 除了映射模式外，还有许多绘图属性可以设置，如背景、绘图方式、多边形填充方式、画弧方向、刷原点等。="" 一、="" 背景="" 背景（background）指绘图区域的底色，可以用cdc类中的成员函数来设置背景色和背景模式。="" 1．背景色="" 当背景模式为不透明时，背景色决定图元中空隙（如虚线中的空隙、条纹刷的空隙和文字的空隙）的颜色，可以使用cdc类的成员函数getbkcolor和setbkcolor来获得和设置当前的背景颜色：="" getbkcolor(="" )="" const;="" 返回当前的背景色="" virtual="" setbkcolor(="" crcolor="" 返回先前的背景色，若出错返回0x80000000，默认的背景色为白色。="" 2．背景模式="" 背景模式影响有空隙的图元中的空隙用什么办法填充。可以使用cdc类的成员函数getbkmode和setbkmode来获得和设置当前的背景模式（参见表8-8）：="" int="" getbkmode(="" 返回当前背景模式="" setbkmode(="" nbkmode="" 返回先前背景模式="" 表8-8="" 背景模式nbkmode的取值="" nbkmode值="" 数值="" 名称="" 作用="" transparent="" 透明的="" 空隙处保持原背景图不变="" opaque="" 不透明的（默认值）="" 空隙用背景色填充="" 二、绘图模式="" 绘图模式（drawing="" mode）指前景色（及原有色）的混合方式，它决定当前画图的笔和刷的颜色（pbcol）如何与原有图的颜色（sccol）相结合而得到结果像素色（pixel）。="" 1．设置绘图模式="" 可使用cdc类的成员函数setrop2="" （其中的rop="Raster" operation，光栅操作）来设置绘图模式：="" setrop2(="" ndrawmode="" 其中，ndrawmode的可取值见表8-9。="" 表8-9="" 绘图模式ndrawmode的取值="" 符号常量="" 运算结果="" r2_black="" 黑色="" pixel="black" r2_notmergepen="" 或非="" |="" pbcol)="" r2_masknotpen="" 与反色="" &="" ~pbcol="" r2_notcopypen="" 反色覆盖="" r2_maskpennot="" 反色与="" pbcol="" r2_not="" 反色="" r2_xorpen="" 异或="" ^="" r2_notmaskpen="" 与非="" r2_maskpen="" 与="" r2_notxorpen="" 异或非="" r2_nop="" 不变="" r2_mergenotpen="" 或反色="" r2_copypen="" 覆盖="" r2_mergepennot="" 反色或="" r2_mergepen="" 或="" r2_white="" 白色="" 其中，r2_copypen（覆盖）为默认绘图模式，r2_xorpen（异或）较为常用。="" 2．画移动图形="" 为了能画移动的位置标识（如十字、一字等图案）和随鼠标移动画动态图形（如直线、矩形、椭圆），必须在不破坏原有背景图形的基础上移动这些图形。="" 移动图形采用的是异或画图方法，移动图形的过程为：异或画图、在原位置再异或化图（擦除）、在新位置异或画图、……。如：="" pgraypen="new" cpen(ps_dot,="" rgb(128,="" 128,="" 128));="" pdc-="">SetBkMode(TRANSPARENT);<br>    pOldPen = pDC-&gt;SelectObject(pGrayPen);<br>    pDC-&gt;SelectStockObject(NULL_BRUSH);<br>    pDC-&gt;SetROP2(R2_XORPEN);<br>    if (m_bErase) pDC-&gt;Ellipse(rect0);<br>    pDC-&gt;Ellipse(rect);<br>    pDC-&gt;SetROP2(R2_COPYPEN);<br>    pDC-&gt;SelectObject(pOldPen);<br>    rect0 = rect;<br>较完整的拖放动态画图的例子，可参照下面的“8.5.4 拖放画动态直线”部分。<br>三、其他属性<br>1．多边形填充方式<br>多边形填充模式（polygon-filling mode）决定复杂多边形的填充方式。<br>虽然GDI中没有画填充多边形的专门函数，但可以用（采用当前刷填充的）画多边形函数Polygon来代替：<br>BOOL Polygon( LPPOINT lpPoints, int nCount );<br>该函数在使用DC中的当前笔画完给定点集确定的边框后，会再用DC中的当前刷填充其内部区域。<br>在画填充多边形时，需要确定一个给定像素点是否在多边形内，常用的方法有两种（参见图8-12）：<br>奇-偶规则（odd-even rule）——从任意给定位置p作一条射线，若与该射线相交的多边形边的数目为奇数，则p是多边形内部点，否则是外部点。例如图8-12中的A点的射线与多边形的边有1个交点为奇数，所以在多边形内部；而B点和C点都有2个交点为偶数，所以都在多边形外部。<br>非零环绕数规则（nonzero winding number rule）——使多边形的边变为矢量。将环绕数初始化为零。再从任意给定位置p作一条射线。当从p点沿射线方向移动时，对在每个方向上穿过射线的边计数，每当多边形的边从右到左穿过射线时，环绕数加1，从左到右时，环绕数减1。处理完多边形的所有相关边之后，若环绕数为非零，则p为内部点，否则，p是外部点。例如图8-12中的A点的射线穿过多边形的一条边，该边的矢量从射线的前进方向的左边穿到右边，环绕数为-1非0，所以A在多边形内部；而B点先+1后-1，最后环绕数为0，所以在多边形外部；而C点先-1再-1，最后环绕数为-2非0，所以也在多边形内部。<br>可见，在图2-12所示的五角星中心的C点，按奇-偶规则在多边形的外部，而按非零环绕数规则在多边形的内部，参见图8-13。<br>在GDI中，可以通过CDC的成员函数SetPolyFillMode来设置以这两种判断方法之一来填充多边形。下面是该函数的原型：<br>int SetPolyFillMode( int nPolyFillMode );<br>其中，多边形填充模式参数nPolyFillMode可取：<br>ALTERNATE（交替）——按奇偶规则填充（默认模式）<br>WINDING（环绕）——按非零环绕规则填充。<br>对简单图形，这两种模式的效果相同。但对复杂的有穿插的图形，结果可能不一样。例如（画五角星，参见图8-13）：</8))|(((dword)(byte)(b))<<16)))></p>
<pre><code>// 定义五角星顶点数组
const int n = 5;
CPoint p1(100, 0), p2(195, 69), p3(159, 181), p4(41, 181), 
p5(5, 69), pm(0, 200)/* 用于向下平移ps2*/;
CPoint ps1[n] = {p1, p2, p3, p4, p5};
CPoint ps2[n] = {pm+p1, pm+p3, pm+p5, pm+p2, pm+p4};
CDC *pDC = GetDC(); // 获取DC
// 选入DC刷并设置成绿色
pDC-&gt;SelectStockObject(DC_BRUSH);
pDC-&gt;SetDCBrushColor(RGB(0, 128, 0));
// 用默认的交替模式画填充五角星
pDC-&gt;Polygon(ps1, n);
pDC-&gt;Polygon(ps2, n);
// 右平移点数组
pm.x = 200; pm.y = 0;
for(int i = 0; i &lt; 5; i++) {
    ps1[i] += pm;  ps2[i] += pm;
}
// 将DC刷设置成红色
pDC-&gt;SetDCBrushColor(RGB(128, 0, 0));
// 设置环绕模式，重新画填充五角星
pDC-&gt;SetPolyFillMode(WINDING);
pDC-&gt;Polygon(ps1, n);
pDC-&gt;Polygon(ps2, n);
ReleaseDC(pDC);
</code></pre><p>还可使用CDC类的成员函数GetPolyFillMode来获取当前多边形的填充方式：<br>int GetPolyFillMode( ) const;<br>2．画弧方向<br>可使用CDC类的成员函数GetArcDirection和SetArcDirection来确定Arc、Chord、Pie等函数的画弧方向：<br>int GetArcDirection( ) const;<br>int SetArcDirection( int nArcDirection );<br>其中，nArcDirection可取值AD_COUNTERCLOCKWISE（逆时针方向，默认值）和AD_CLOCKWISE（顺时针方向）<br>3．刷原点<br>可使用CDC类的成员函数GetBrushOrg和SetBrushOrg来确定可填充绘图函数的条纹或图案刷的起点：（默认值为客户区左上角的坐标原点（0, 0））<br>CPoint GetBrushOrg( ) const;<br>CPoint SetBrushOrg( int x, int y );<br>CPoint SetBrushOrg( POINT point );<br>8.3.6几何对象的结构和类<br>为了使用绘图函数，应该先了解绘图所用到的几种表示几何对象的结构和类，包括点、大小和矩形，其中常用的是点和矩形。这些结构和类被分别定义在头文件windef.h和afxwin.h中。MFC中的几何对象类都是独立的类（不是CObject的派生类），是对API中对应结构的C++封装。</p>
<p>一、点<br>点（point）在API中的结构为POINT，对应的MFC类为CPoint。<br>1．点结构POINT<br>API中的点数据结构POINT用来表示一点的x、y坐标：<br>typedef struct tagPOINT { LONG x; LONG y; } POINT;<br>其中，类型LONG（32位整数）的定义为：typedef long LONG;<br>2．点类CPoint<br>MFC中的点类CPoint为一个没有基类的独立类，封装了POINT结构，有成员变量x和y，其构造函数有5种：<br>CPoint( ); // 默认<br>CPoint( int initX, int initY ); // 常用<br>CPoint( POINT initPt );<br>CPoint( SIZE initSize );<br>CPoint( LPARAM dwPoint ); // 低字设为x、高字设为y<br>CPoint类还定义了4个平移和设置的成员函数：<br>void Offset(int xOffset, int yOffset);<br>void Offset(POINT point);<br>void Offset(SIZE size);<br>void SetPoint(int X, int Y);<br>另外，CPoint类还重载了+、-、+=、-=、==、!= 等运算符来支持CPoint对象和CPoint、POINT、SIZE对象之间的运算。<br>二、大小<br>大小（size，尺寸）在API中的结构为SIZE，在MFC中的类为CSize。<br>1．大小结构SIZE<br>大小结构SIZE用来表示矩形的宽cx和高cy：<br>typedef struct tagSIZE { LONG cx; LONG cy; } SIZE;<br>2．大小类CSize<br>MFC中的大小类CSize也为一个没有基类的独立类，封装了SIZE结构，有成员变量cx和cy，其构造函数也有5种：<br>CSize( );<br>CSize( int initCX, int initCY );<br>CSize( SIZE initSize );<br>CSize( POINT initPt );<br>CSize( DWORD dwSize ); // 低字设为cx、高字设为cy<br>CSizet类也重载了+、-、+=、-=、==、!= 等运算符来支持CSize对象和CSize、POINT、SIZE、RECT对象之间的运算。<br>三、矩形<br>矩形（rectangle）在API中的结构为RECT，在MFC中的类为CRect。<br>1．矩形结构RECT<br>API中的矩形结构RECT定义了矩形的左上角与右下角的坐标：<br>typedef struct tagRECT { LONG left; LONG top; LONG right; LONG bottom;} RECT;<br>2．矩形类CRect<br>MFC中的矩形类CRect也为一个没有基类的独立类，封装了RECT结构，有成员变量left、top、right和bottom，其构造函数有6种：<br>CRect( ); // 默认<br>CRect( int l, int t, int r, int b ); // 常用<br>CRect( const RECT&amp; srcRect );<br>CRect( LPCRECT lpSrcRect );<br>CRect( POINT point, SIZE size );<br>CRect( POINT topLeft, POINT bottomRight );<br>CRect类重载了=，+、-，+=、-=，==、!=，&amp;、|，&amp;=、|= 等运算符来支持CRect对象和CRect、POINT、SIZE、RECT对象之间的运算。还定义了转换符LPCRECT和LPRECT来自动完成CRect对象到矩形结构和类指针LPCRECT和LPRECT的转换。<br>CRect类中常用的属性和成员函数有：<br>int Width( ) const;<br>int Height( ) const;<br>CSize Size( ) const;<br>CPoint&amp; TopLeft( );<br>CPoint&amp; BottomRight( );<br>CPoint CenterPoint( ) const;<br>void SwapLeftRight();<br>BOOL IsRectEmpty( ) const;<br>BOOL PtInRect( POINT point ) const;<br>void SetRect( int x1, int y1, int x2, int y2 );<br>void SetRect(POINT topLeft, POINT bottomRight);<br>void OffsetRect(int x, int y);<br>void MoveToXY(int x, int y);<br>3．判断点是否在矩形中<br>有时需要判断某点（如鼠标位置）是否在某一矩形区域（如控件）中，这可以调用CRect类的PtInRect函数来做：<br>BOOL PtInRect( POINT point ) const;<br>该函数当点point在其矩形区域内时，返回真。注意，该矩形区域不包括矩形的右边界和底边界。例如：<br>CRect rect( 10, 10, 371, 267 );<br>void CDrawView::OnLButtonUp(UINT nFlags, CPoint point)<br>{<br>    // TODO: 在此添加消息处理程序代码和/或调用默认值<br>    if ( rect.PtInRect( point ) ) … …<br>    CView::OnLButtonUp(nFlags, point);<br>}<br>四、获得客户区大小<br>绘图一般都是在框架窗口的客户区（对应于视图类）进行，而客户区的大小在运行时可由用户动态改变，为了使绘制的图形能随窗口大小而自动改变，需先得到当前客户区大小的数据（宽和高）。<br>获取客户区大小的方法有如下两种：<br>1．OnSize<br>获取客户区大小的第一种方法是通过消息响应函数OnSize中获得。<br>可利用属性窗口的消息页，为视图类添加WM_SIZE消息的响应函数OnSize。该函数会在窗口第一次显示或窗口大小被改变时被系统调用。其输入参数中的cx和cy就是当前客户区的宽和高，可将它们赋值给类变量（如m_iW和m_iH）供绘图时使用。例如：<br>void CDrawView::OnSize(UINT nType, int cx, int cy) {<br>    CView::OnSize(nType, cx, cy);<br>    // TODO: 在此处添加消息处理程序代码<br>    m_iW = cx;  m_iH = cy;<br>}<br>其中，nType的值为：<br>    SIZE_MAXIMIZED（窗口已被最大化）<br>    SIZE_MINIMIZED（窗口已被最小化）<br>    SIZE_RESTORED（窗口已被改变大小）<br>    SIZE_MAXHIDE（其他窗口被最大化）<br>    SIZE_MAXSHOW（其他窗口从最大化还原）<br>2．GetClientRect<br>获取客户区大小的第二种方法是调用窗口类的获取客户区矩形成员函数GetClientRect来得到。具体做法是，在绘图前定义一个矩形结构变量rect，然后再调用CWnd类的成员函数GetClientRect来得到当前客户区矩形的数据，该函数的原型为：<br>void GetClientRect( LPRECT lpRect ) const;<br>其中，矩形结构的右（right）与底（bottom）就是客户区的宽与高（其左left与顶top都为0）。例如：<br>    RECT rect;<br>    GetClientRect(&amp;rect);<br>    int iW = rect.right, iH = rect.bottom;<br>8.4 画笔和画刷<br>8.4.1画笔<br>在Windows中，线状图必须用笔（pen）来画，所以线的颜色就由笔色来确定。在MFC中，笔的属性和功能由CPen类提供（CPen是CGDIObject的派生类）。<br>笔的创建与使用的步骤为：<br>1．创建笔对象<br>创建CPen类笔对象的方法有如下两种：<br>    使用非默认构造函数创建初始笔：<br>CPen( int nPenStyle, int nWidth, COLORREF crColor );<br>其中：<br>    nPenStyle为笔的风格，可取值见表8-3。<br>表8-3  笔风格nPenStyle值<br>符号常量    数值    风格名称    线例<br>PS_SOLID    0    实心    </p>
<p>PS_DASH    1    虚线    </p>
<p>PS_DOT    2    点线    </p>
<p>PS_DASHDOT    3    虚点线    </p>
<p>PS_DASHDOTDOT    4    虚点点线    </p>
<p>PS_NULL    5    空笔<br>PS_INSIDEFRAME    6    框内<br>注意：1~4号笔风格只是在笔宽=0或1时有效，笔宽&gt;1时总为实心的。<br>                     线例<br>符号常量    数值    风格名称    线例<br>PS_SOLID    0    实心    </p>
<p>PS_DASH    1    虚线    </p>
<p>PS_DOT    2    点线    </p>
<p>PS_DASHDOT    3    虚点线    </p>
<p>PS_DASHDOTDOT    4    虚点点线    </p>
<p>PS_NULL    5    空笔<br>PS_INSIDEFRAME    6    框内    </p>
<p>nWidth为笔宽，与映射模式有关，使用默认映射时为像素数，若nWidth = 0，则不论什么映射模式，笔宽都为一个像素。<br>crColor为笔的颜色值。<br>默认的笔为单像素宽的黑色实心笔。<br>例如：<br>CPen<em> pGrayPen = new CPen(PS_SOLID, 0, RGB(128, 128, 128));<br>CPen grayPen(PS_SOLID, 0, RGB(128, 128, 128));<br>使用成员函数CreatePen（多次）创建笔：<br>BOOL CreatePen( int nPenStyle, int nWidth, COLORREF crColor );<br>可先用CPen类的默认构造函数创建一个空笔对象，然后再调用CreatePen创建具有新内容的笔，例如：<br>CPen grayPen;<br>grayPen.CreatePen(PS_SOLID, 0, RGB(128, 128, 128));<br>不过在用CreatePen创建新笔之前，必须先调用DeleteObject函数删除笔对象的内容。该函数是CPen的基类CGDIObject的成员函数，下面是它的原型：<br>BOOL DeleteObject( );<br>2．选笔入DC<br>为了能使用我们自己所创建的笔对象，必须先将它选入DC，这可以调用设备上下文类CDC的成员函数SelectObject来完成：<br>CPen</em> SelectObject( CPen<em> pPen );<br>该函数的返回值为指向原来笔对象的指针（一般将其保存下来，供下次选出新笔时使用）。例如：<br>pOldPen = pDC-&gt;SelectObject(&amp;pen);<br>另外，Windows中有一些预定义的笔对象（参见表8-4），可用CDC的另一成员函数SelectStockObject将其选入DC，其函数原型为：<br>virtual CGdiObject</em> SelectStockObject( int nIndex );<br>表8-4  预定义笔<br>符号常量    数值    笔<br>WHITE_PEN    6    白色笔<br>BLACK_PEN    7    黑色笔<br>NULL_PEN    8    空笔<br>DC_PEN    19    DC笔<br>其中，DC笔为单色实心笔，默认为黑色。是从Windows NT/2000开始新引进的，可用于直接设置笔色，参见本小节后面的第6部分。<br>例如：<br>pDC-&gt;SelectStockObject(BLACK_PEN);<br>3．绘制线状图<br>在将笔对象选入DC后，就可以使用CDC类中的绘图函数，利用DC中的笔对象，来画线状图及面状图的边线。如果不创建和选入笔对象，则使用的是DC中的默认笔，为单像素宽的实心黑色笔。<br>Windows中的线状图有直线、折线、矩形、（椭）圆（弧）等，详见8.5.3。<br>4．删除笔<br>不能直接删除已使用过的笔对象，必须先将它从DC中释放出来后才能删除。释放的方法是装入其他的笔对象（一般是重新装入原来的笔对象）。例如：<br>pDC-&gt;SelectObject(pOldPen);<br>删除笔对象的方法有如下几种：<br>删除笔内容：调用笔类CDC的成员函数DeleteObject删除笔的当前内容（但是未删除笔对象，以后可再用成员函数CreatePen在笔对象中继续创建新的笔内容）。例如：pen.DeleteObject();<br>删除笔对象：使用删除运算符delete将笔对象彻底删除，例如delete &pen;。<br>自动删除：若笔对象为局部变量，则在离开其作用域时，笔对象会被系统自动删除。<br>5．例子<br>下面为一段较完整地创建与使用笔的例子代码：<br>    CDC<em> pDC = GetDC(); // 获取DC<br>    CPen pen, </em>pOldPen; // 定义笔对象和指针<br>    // 创建10单位宽的绿色实心笔<br>    pen.CreatePen(PS_SOLID, 10, RGB(0, 255, 0));<br>    pOldPen = pDC-&gt;SelectObject(&amp;pen); // 选入绿色笔<br>    pDC-&gt;Rectangle(10, 10, 100, 100); // 画矩形<br>    pDC-&gt;SelectObject(pOldPen); // 选出绿色笔<br>    pen.DeleteObject(); // 删除绿色笔<br>    // 创建单像素宽的红色虚线笔<br>    pen.CreatePen(PS_DASH, 0, RGB(255, 0, 0));<br>    pOldPen = pDC-&gt;SelectObject(&amp;pen); // 选入红色笔<br>    pDC-&gt;MoveTo(10, 10); pDC-&gt;LineTo(100, 100); // 画直线<br>    ReleaseDC(pDC); // 释放DC<br>6．设置DC笔颜色<br>对Windows NT/2000及以上的版本，如果只需修改实心笔的颜色，而不需改变笔的粗细，则可以不用反复创建和选入新笔，而使用CDC类的成员函数SetDCPenColor，来直接设置DC笔的颜色：<br>COLORREF SetDCPenColor( COLORREF crColor ); // 返回原颜色值<br>对应的获取DC三笔颜色的成员函数为：<br>COLORREF GetDCPenColor( ) const;<br>不过这需要先调用CDC的成员函数SelectStockObject将DC笔选入DC后，才能使用SetDCPenColor函数来设置DC中笔的颜色。例如：<br>    pDC-&gt;SelectStockObject(DC_PEN); // 选入DC笔<br>    pDC-&gt;SetDCPenColor(RGB(255, 0, 0)); // 设置成红色<br>实例代码1：<br>Cpen<br>CDC<em>pDC=GetDC();<br>CPen pen;<br>pen.CreatePen(PS_SOLID,5,RGB(255,0,0));<br>CPen</em> pOldPen=pDC-&gt;SelectObject(&amp;pen);<br>pDC-&gt;LineTo(400,600);<br>pDC-&gt;SelectObject(pOldPen);<br>ReleaseDC(pDC); // 释放DC<br>实例代码2：<br>CDC<em>pDC=GetDC();<br>CPen pen;<br>pen.CreatePen(PS_SOLID,5,RGB(255,0,0));<br>CPen</em> pOldPen=pDC-&gt;SelectObject(&amp;pen);<br>CRect rect;<br>GetClientRect(rect);  //获得用户区域大小<br>CPoint pts[4];<br>pts[0].x = rect.left + rect.Width()/2;<br>pts[0].y = rect.top;<br>pts[1].x = rect.right;<br>pts[1].y = rect.top + rect.Height()/2;<br>pts[2].x = pts[0].x;<br>pts[2].y = rect.bottom;<br>pts[3].x = rect.left;<br>pts[3].y = pts[1].y;<br>pDC-&gt;Polygon(pts,4);<br>pDC-&gt;SelectObject(pOldPen);<br>ReleaseDC(pDC); // 释放DC<br>8.4.2画刷<br>在Windows中，面状图必须用刷（brush）来填充，所以面色是由刷色来确定的。MFC中的刷类为CBrush（它也是CGDIObject的派生类），刷的创建与使用的步骤与笔的相似。<br>1．构造函数<br>CBrush类有4个构造函数，分别用于创建空刷、实心刷、条纹刷和图案刷：<br>CBrush( ); // 创建一个刷的空对象<br>CBrush( COLORREF crColor ); // 创建颜色为crColor的单色实心刷<br>CBrush( int nIndex, COLORREF crColor ); // 创建风格由nIndex指定且颜色为crColor的条纹（hatch，孵化/影线）刷，其中nIndex可取条纹风格（Hatch Styles）值见表8-5和图8-4。<br>表8-5  条纹风格nIndex值<br>符号常量    数值    风格<br>HS_HORIZONTAL    0    水平线<br>HS_VERTICAL    1    垂直线<br>HS_FDIAGONAL    2    正斜线<br>HS_BDIAGONAL    3    反斜线<br>HS_CROSS    4    十字线(正网格)<br>HS_DIAGCROSS    5    斜十字线(斜网格)</p>
<p> 水平线   垂直线   正斜线  反斜线  十字线  斜十字线<br>图8-4 条纹刷的种类<br>    CBrush（CBitmap<em> pBitmap）; // 创建位图为pBitmap的图案（pattern）刷<br>默认的刷为白色实心刷。<br>2．创建函数<br>与构造函数相对应，CBrush类有多个创建不同类型刷的成员函数，如：<br>BOOL CreateSolidBrush( COLORREF crColor ); // 创建（单色）实心刷<br>BOOL CreateHatchBrush( int nIndex, COLORREF crColor ); // 创建条纹刷<br>BOOL CreatePatternBrush( CBitmap</em> pBitmap ); // 创建图案刷<br>3．预定义刷<br>预定义的刷对象见表8-6有：<br>表8-6  预定义刷<br>符号常量    数值    刷<br>WHITE_BRUSH    0    白刷（默认）<br>LTGRAY_BRUSH    1    亮灰刷<br>GRAY_BRUSH    2    灰刷<br>DKGRAY_BRUSH    3    暗灰刷<br>BLACK_BRUSH    4    黑刷<br>HOLLOW_BRUSH    5    空刷<br>NULL_BRUSH    5    空刷<br>DC_BRUSH    18    DC刷<br>其中，DC刷为单色实心刷，默认为白色。是从Windows NT/2000开始新引进的，可用于直接设置刷色，参见本小节后面的第5部分。<br>3．选入刷<br>与笔一样，可以用函数SelectObject或SelectStockObject将自定义刷或预定义刷选入DC中，供绘面状图时使用。如果未选入任何刷，则系统会使用DC中的默认刷来绘图，默认刷为白色实心刷。<br>4．例子<br>下面是一个创建、选入并使用自定义实心刷的简单例子代码段：<br>CRect rect(10, 10, 210, 160);<br>CBrush brush(RGB(0, 255, 0));<br>CDC<em> pDC = GetDC();<br>pDC-&gt;SelectObject(&amp;brush);<br>pDC-&gt;Rectangle(&amp;rect);<br>ReleaseDC(pDC);<br>5．设置DC刷色<br>对Windows NT/2000及以上的版本，如果只需修改实心刷的颜色，而不改变刷的种类和风格，则可以不用反复创建和选入新刷，而使用CDC类的成员函数SetDCBrushColor，来直接设置DC刷的颜色：<br>COLORREF SetDCBrushColor( COLORREF crColor ); // 返回原颜色值<br>对应的获取DC中刷颜色的成员函数为：<br>COLORREF GetDCBrushColor( ) const;<br>与设置DC笔类似，也需要先调用CDC的成员函数SelectStockObject将DC刷选入DC后，才能使用SetDCBrushColor函数来设置DC中刷的颜色。例如：<br>pDC-&gt;SelectStockObject(DC_BRUSH); // 选入DC刷<br>pDC-&gt;SetDCBrushColor(RGB(255, 0, 0)); // 设置成红色<br>6．例子<br>CDC</em>pDC=GetDC();<br>CBrush brush(HS_CROSS,RGB(0,255,0));<br>CBrush<em> pOldBrush=pDC-&gt;SelectObject(&amp;brush);<br>pDC-&gt;Ellipse(50,50,300,400);<br>pDC-&gt;SelectObject(pOldBrush);<br>ReleaseDC(pDC); // 释放DC<br>7.画笔画刷例子（在控件上绘图）<br>本实例建立一个项目，项目功能是点击菜单“波形线”，弹出一个对话框，点击按钮“画波形”则在对话框的一个图片控件的黑色背景上画出绿色波形线。<br>（1）建立一个项目，名字为boxing，建立一个菜单“画波形线”。<br>（2）插入一个对话框，在对话框上添加一个picture  control控件，修改该控件的id为IDC_PIC(如果不修改id，可能无法为其添加静态变量)，并为其添加一个静态变量（static）m_pic，添加一个按钮，caption属性改为波形线，为其添加函数（可通过直接双击该按钮添加函数）。<br>（3）在按钮函数里添加代码画波形线：<br>CRect  rectPicture;<br>CPen newPen;//用于创建新画笔<br>CPen</em>pOldPen;//用于存放旧画笔<br>CBrush newBrush;//用于创建新画刷<br>CBrush<em>pOldBrush;//用于存放旧画刷<br>float fDeltaX,fDeltaY;<br>float fDeltaX,fDeltaY;<br>int nX,nY;<br>CWnd </em>pWin = GetDlgItem(IDC_PIC);<br>CDC <em>pDC = pWin-&gt;GetDC();<br>//获取绘图控件的客户区坐标<br>//（客户区坐标以窗口的左上角为原点，这区别于以屏幕左上角为原点的屏幕坐标）<br>m_pic.GetClientRect(&amp;rectPicture);<br>//创建黑色新画刷<br>newBrush.CreateSolidBrush(RGB(0,0,0));<br>//选择新画刷，并将旧画刷的指针保存到pOldBrush<br>pOldBrush=pDC-&gt;SelectObject(&amp;newBrush);<br>    //以黑色画刷为绘图控件填充黑色，形成黑色背景<br>pDC-&gt;Rectangle(rectPicture);<br>//恢复旧画刷<br>pDC-&gt;SelectObject(pOldBrush);<br>//删除新画刷<br>newBrush.DeleteObject();<br>//创建实心画笔，粗度为1，颜色为绿色<br>newPen.CreatePen(PS_SOLID,1,RGB(0,255,0));<br>//选择新画笔，并将旧画笔的指针保存到pOldPen<br>pOldPen=pDC-&gt;SelectObject(&amp;newPen);<br>//将当前点移动到绘图控件窗口的左下角，以此为波形的起始点<br>pDC-&gt;MoveTo(rectPicture.left,rectPicture.bottom);<br>//计算fDeltaX和fDeltaY<br>fDeltaX=(float)rectPicture.Width()/(100);<br>fDeltaY=(float)rectPicture.Height()/100;<br>//计算m_nzValues数组中每个点对应的坐标位置，并依次连接，最终形成曲线<br>    for(int i=0;i&lt;100;i++)<br>    {<br>        nX=rectPicture.left+(int)(i</em>fDeltaX);<br>        //nY=rectPicture.bottom-(int)(m_nzValues[i]*fDeltaY);<br>        //(rand()%rectPicture.Height()为产生图片框高度值内的随机数<br>        nY=rectPicture.bottom-(int)(rand()%rectPicture.Height());<br>        pDC-&gt;LineTo(nX,nY);<br>    }<br>    //恢复旧画笔<br>    pDC-&gt;SelectObject(pOldPen);<br>    //删除新画笔、画刷<br>    newPen.DeleteObject();<br>    newBrush.DeleteObject();<br>    ReleaseDC(pDC); // 释放DC<br>（4）调试运行观察结果<br>运行正确结果应该为：</p>
<p>8.5 绘图<br>8.5.1 绘图步骤<br>图8-11描述了一般MFC绘图的基本步骤（及相关的类型和函数）。</p>
<p>图8-11  绘图的基本步骤<br>（其中：<em>为PEN或BRUSH，<strong>为Pen或Brush，
</strong></em>为Pen或SolidBrush、HatchBrush、PatternBrush）<br>8.5.2 画像素点<br>在Windows中，像素（pixel）的颜色是直接由CDC类的成员函数SetPixel来设置的，该函数的原型为：<br>COLORREF SetPixel( int x, int y, COLORREF crColor );<br>COLORREF SetPixel( POINT point, COLORREF crColor );<br>其中，x与y分别为像素点的横坐标与纵坐标，crColor为像素的颜色值。例如：<br>pDC-&gt;SetPixel(10, 10, RGB(0, 255, 0));<br>    另外，还可以用CDC的成员函数<br>COLORREF GetPixel( int x, int y ) const;<br>COLORREF GetPixel( POINT point ) const;<br>来获得指定点（x, y）或point的颜色。例如：<br>    COLORREF col;<br>    col = pDC-&gt;GetPixel(10, 10);<br>画像素点就是设置像素点的颜色，可由CDC的成员函数SetPixel来做。<br>8.5.3 画线状图<br>在众多的绘图状态中，有一个是当前位置（current position），有些画线状图的函数（如MoveTo、LineTo和AngleArc）与它有关。<br>在Windows中，线状图必须用笔来画（笔的创建与使用见前面的8.3.3），下面是CDC类中可以绘制线状图的常用成员函数：<br>    当前位置——设置当前位置为（x, y）或point：（返回值为原当前位置的坐标）：<br>CPoint MoveTo( int x, int y ); 或 CPoint MoveTo( POINT point );<br>    画线——使用DC中的笔，从当前位置画线到点（x, y）或point（成功返回非0值）：<br>BOOL LineTo( int x, int y ); 或BOOL LineTo( POINT point );<br>你可以自己定义一个画线函数，如：<br>BOOL Line(CDC <em>pDC, int x1, int y1, int x2, int y2 ) {<br>    pDC-&gt; MoveTo(x1, y1);<br>    return pDC-&gt; LineTo(x2, y2);<br>}<br>或<br>BOOL Line(CDC </em>pDC, POINT p1, POINT p2 ) {<br>    pDC-&gt; MoveTo(p1);<br>    return pDC-&gt; LineTo(p2);<br>}<br>函数成功时，设置当前位值为（x, y）或point。<br>    画折线——使用DC中的笔，依次将点数组lpPoints中的nCount（≥2）个点连接起来，形成一条折线：<br>BOOL Polyline( LPPOINT lpPoints, int nCount );<br>该函数不使用和设置当前位置。<br>画多边形——似画折线，但还会将最后的点与第一个点相连形成多边形，并用DC中的刷填充其内部区域：<br>BOOL Polygon( LPPOINT lpPoints, int nCount );<br>该函数也不使用和设置当前位置。<br>画矩形——使用DC中的笔，画左上角为（x1, y1）、右下角为（x2, y2）或范围为<em>lpRect的矩形的边线，并用DC中的刷填充其内部区域：<br>BOOL Rectangle( int x1, int y1, int x2, int y2 ); 或<br>BOOL Rectangle( LPCRECT lpRect );<br>该函数也不使用和设置当前位置。有时需要根据用户给定的两个任意点（如p0和point）来重新构造左上角和右下角的点，例如：<br>rect = CRect(min(p0.x, point.x), min(p0.y, point.y),<br>max(p0.x, point.x), max(p0.y, point.y));<br>画圆角矩形——使用DC中的笔，画左上角为（x1, y1）、右下角为（x2, y2）或范围为</em>lpRect的矩形的边线，并用宽为x3或point.x、高为y3或point.y矩形的内接椭圆倒角（参见图8-9 a)），再用DC中的刷填充其内部区域：<br>BOOL RoundRect( int x1, int y1, int x2, int y2, int x3, int y3 );<br>BOOL RoundRect( LPCRECT lpRect, POINT point );<br>该函数也不使用和设置当前位置。例如：<br>int d = min(rect.Width(), rect.Height()) / 4;<br>pDC-&gt; RoundRect(rect, CPoint(d, d));</p>
<p>a) 圆角矩形                        b) 椭圆<br>图8-9  圆角矩形与椭圆<br>画（椭）圆——使用DC中的笔，在左上角为（x1, y1）、右下角为（x2, y2）或范围为<em>lpRect的矩形中画内接（椭）圆的边线（当边线宽度超过1时会向外延伸，参见图8-9 b)），并用DC中的刷填充其内部区域：<br>BOOL Ellipse( int x1, int y1, int x2, int y2 );<br>BOOL Ellipse( LPCRECT lpRect );<br>该函数也不使用和设置当前位置。注意，CDC中没有画圆的专用函数，圆是作为椭圆的（宽高相等）特例来画的。从此函数很容易定义自己的画圆函数，例如：<br>BOOL Circle( CDC </em>pDC, int x, int y, int r ) {<br>    return pDC-&gt;Ellipse( x - r, y - r, x + r, y + r );<br>}<br>或<br>BOOL Circle( CDC *pDC, POINT p, int r ) {<br>    return pDC-&gt;Ellipse( p.x - r, p.y - r, p.x + r, p.y + r );<br>}<br>画弧——使用DC中的笔，在由（含义同画椭圆的）（x1, y1）与（x2, y2）或lpRect确定的椭圆上，以（x3, y3）或ptStart为起点、（x4, y4）或ptEnd为终点，按逆时针方向（可以用CDC的成员函数SetArcDirection修改成顺时针方向）旋转画弧（参见图8-10 a)）：<br>BOOL Arc( int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4 );<br>BOOL Arc( LPCRECT lpRect, POINT ptStart, POINT ptEnd );<br>BOOL ArcTo(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);<br>BOOL ArcTo(LPCRECT lpRect, POINT ptStart, POINT ptEnd);<br>该函数也不使用和设置当前位置。</p>
<p>a) 弧与弓弦                        b) 直线段和圆弧<br>图8-10  弧与弓弦、直线段和圆弧<br>画弓弦——参数的含义同上，只是用一根弦连接弧的起点和终点，形成一个弓形（参见图8-10 a)），并用DC中的刷填充其内部区域：<br>BOOL Chord( int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4 );<br>BOOL Chord( LPCRECT lpRect, POINT ptStart, POINT ptEnd );<br>该函数也不使用和设置当前位置。<br>画直线段和圆弧——从当前位置画一直线段到弧的起点，并画一指定圆弧（其中（x, y）为圆心、nRadius为半径、fStartAngle为起始角度、fSweepAngle为弧段跨角，参见图8-10 b)）：<br>BOOL AngleArc(int x, int y, int nRadius, float fStartAngle, float fSweepAngle);<br>函数成功时，设置当前位置为弧的终点。<br>8.5.4 拖放画动态直线<br>下面是一个较完整的拖放动态画直线的例子，可用于本章的交互绘图的必做作业中。其中粗体字为手工添加的部分：<br>// 类变量<br>class CDrawView : public CView {<br>    //……<br>// 属性<br>public:<br>    //……<br>    BOOL m_bLButtonDown, // 判断是否按下左鼠标键<br>    m_bErase; // 是否需要擦除图形的类变量<br>    CPoint p0, pm; // 记录直线起点和动态终点的类变量<br>    CPen <em>pGrayPen, </em>pLinePen; // 定义灰色和直线笔<br>    //……<br>}<br>// 构造函数<br>CDrawView::CDrawView() {<br>    m_bLButtonDown = FALSE; // 设左鼠标键按下为假<br>    m_bErase = FALSE; // 设需要擦除为假<br>    pGrayPen = new CPen(PS_DOT, 0, RGB(128, 128, 128)); // 创建灰色点线笔<br>    pLinePen = new CPen(PS_SOLID, 10, RGB(255, 0, 0)); // 创建红色的直线笔<br>}<br>// 鼠标消息响应函数<br>void CDrawView::OnLButtonDown(UINT nFlags, CPoint point) {<br>    // TODO: 在此添加消息处理程序代码和/或调用默认值<br>    SetCapture(); // 设置鼠标捕获<br>    m_bLButtonDown = TRUE; // 设左鼠标键按下为真<br>    p0 = point; // 保存直线的起点<br>    pm = p0; // 让直线的终点等于起点<br>    CView::OnLButtonDown(nFlags, point);<br>}<br>void CDrawView::OnMouseMove(UINT nFlags, CPoint point) {<br>    SetCursor(LoadCursor(NULL, IDC_CROSS)); // 设置鼠标为十字<br>    if (m_bLButtonDown) { // 左鼠标键按下为真<br>    CDC<em> pDC = GetDC(); // 获取设备上下文<br>    pDC-&gt;SelectObject(pGrayPen); // 选取灰色点线笔<br>    pDC-&gt;SetROP2(R2_XORPEN); // 设置为异或绘图方式<br>    pDC-&gt;SetBkMode(TRANSPARENT); // 设置透明背景模式<br>    //pDC-&gt;SelectStockObject(NULL_BRUSH); // 选入空刷<br>// 用于动态画封闭图形（如矩形、椭圆等）<br>    if (m_bErase) { // 需要擦除为真<br>    pDC-&gt;MoveTo(p0); pDC-&gt;LineTo(pm); // 擦除原直线<br>        }<br>        else // 需要擦除为假<br>        m_bErase = TRUE; // 设需要擦除为真<br>        pDC-&gt;MoveTo(p0); pDC-&gt;LineTo(point); // 绘制新直线<br>        pm = point; // 更新老终点<br>        ReleaseDC(pDC); // 释放设备上下文<br>    }<br>    CView::OnMouseMove(nFlags, point);<br>}<br>void CDrawView::OnLButtonUp(UINT nFlags, CPoint point) {<br>    ReleaseCapture(); // 释放鼠标捕获<br>    if (m_bLButtonDown) { // 左鼠标键按下为真<br>        CDC</em> pDC = GetDC(); // 获取设备上下文<br>        pDC-&gt;SelectObject(pGrayPen); // 选入灰色点线笔<br>        pDC-&gt;SetROP2(R2_XORPEN); // 设置为异或绘图方式<br>        pDC-&gt;SetBkMode(TRANSPARENT); // 设置透明背景模式<br>        // pDC-&gt;SelectStockObject(NULL_BRUSH); // 选入空刷<br>// 用于动态画封闭图形（如矩形、椭圆等）<br>        pDC-&gt;MoveTo(p0); pDC-&gt;LineTo(pm); // 擦除原直线<br>        pDC-&gt;SelectObject(pLinePen); // 选择直线笔<br>        pDC-&gt;SetROP2(R2_COPYPEN); // 设置为覆盖绘图方式<br>        pDC-&gt;MoveTo(p0); pDC-&gt;LineTo(point); // 绘制最终的直线<br>        m_bLButtonDown = FALSE; // 重设左鼠标键按下为假<br>        m_bErase = FALSE; // 重需要擦除为假<br>        ReleaseDC(pDC); // 释放设备上下文<br>    }<br>    CView::OnLButtonUp(nFlags, point);<br>}<br>图8-14是鼠标交互拖放动态画图的主要步骤图：</p>
<p>图8-14  拖放动态画图的主要步骤<br>其中移动图形（OnMouseMove）和绘制用户图形（成图，OnLButtonUp）的主要步骤分别见图8-15和16。</p>
<p>图8-15  移动图形的主要步骤</p>
<p>图8-16  成图的主要步骤<br>8.5.5 画填充图<br>在Windows中，面状图必须用刷来填充（刷的创建与使用见前面8.3.4）。上面8.4.3中的Polygon、Rectangle、Ellipse和Chord等画闭合线状图的函数，只要DC中的刷不是空刷，都可以用来画对应的面状图（边线用当前笔画，内部用当前刷填充）。下面介绍的是CDC类中只能绘制面状图的其他常用成员函数：<br>    画填充矩形——用指定的刷pBrush画一个以lpRect为区域的填充矩形，无边线，填充区域包括矩形的左边界和上边界，但不包括矩形的右边界和下边界：<br>void FillRect( LPCRECT lpRect, CBrush<em> pBrush );<br>画单色填充矩形——似FillRect，但只能填充单色，不能填充条纹和图案：<br>void FillSolidRect( LPCRECT lpRect, COLORREF clr );<br>void FillSolidRect( int x, int y, int cx, int cy, COLORREF clr );<br>画饼图（扇形）——参数含义同Arc，但将起点和终点都与外接矩形的中心相连接，形成一个扇形区域，用DC中的刷填充整个扇形区域，无另外的边线：<br>BOOL Pie( int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4 );<br>BOOL Pie( LPCRECT lpRect, POINT ptStart, POINT ptEnd );<br>画拖动的矩形——先擦除线宽为sizeLast、填充刷为pBrushLast的原矩形lpRectLast，然后再以线宽为size、填充刷为pBrush画新矩形lpRectLast。矩形的边框用灰色的点虚线画，默认的填充刷为空刷：<br>void DrawDragRect( LPCRECT lpRect, SIZE size, LPCRECT lpRectLast,<br>SIZE sizeLast, CBrush</em> pBrush = NULL, CBrush<em> pBrushLast = NULL );<br>如：pDC-&gt;DrawDragRect(rect, size, rect0, size);<br>填充区域——有如下两种填充区域的函数：<br>使用当前刷从点（x, y）开始向四周填充到颜色为crColor的边界：<br>BOOL FloodFill(int x, int y, COLORREF crColor); // 成功返回非0<br>使用当前刷从点（x, y）开始向四周填充：<br>BOOL ExtFloodFill(int x, int y, COLORREF crColor,<br>UINT nFillType); // 成功返回非0<br>nFillType = FLOODFILLBORDER：填充到颜色为crColor的边界（同FloodFill）；（用于填充内部颜色不同但边界颜色相同的区域）<br>nFillType = FLOODFILLSURFACE：填充所有颜色为crColor的点，直到碰到非crColor颜色的点为止。（点（x, y）的颜色也必须为crColor），（用于填充内部颜色相同但边界颜色可以不同的区域）。例如：<br>pDC-&gt;ExtFloodFill(point.x, point.y,<br>pDC-&gt;GetPixel(point), FLOODFILLSURFACE);<br>8.5.6 清屏<br>Windows API和MFC中都没有提供专门的GDI清屏函数，可以依次调用CWnd的下面两个函数调用来完成该功能：<br>void Invalidate(BOOL bErase = TRUE); // 使窗口内容无效<br>void UpdateWindow( ); // 更新窗口<br>或等价地调用一个CWnd的函数<br>BOOL RedrawWindow(<br>   LPCRECT lpRectUpdate = NULL,<br>   CRgn</em> prgnUpdate = NULL,<br>   UINT flags = RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE<br>);<br>来完成。这两组函数都是先用当前背景色（默认为白色）填充窗口，再请求操作系统重绘窗口（调用OnDraw或OnPaint函数）。例如（菜单项ID_CLEAR的事件处理函数）：<br>CDrawView::OnClear() { // 调用OnDraw来清屏<br>    //Invalidate(); UpdateWindow( );<br>    RedrawWindow( );<br>}<br>也可以用画填充背景色矩形的方法来手工直接清屏，例如：<br>    RECT rect;<br>    GetClientRect(&amp;rect);<br>    pDC-&gt;FillSolidRect(&amp;rect, RGB(255, 255, 255));<br>8.5.7 在控件上绘图<br>在对话框类的OnPaint函数中对图片框架控件绘图相对容易，而在其他控件上绘图，则必须依次调用窗口的无效和更新函数后，再调用各种CDC类的成员函数进行绘图。本小节内容，可用于本章的调色板选做作业。<br>1．在图片框架控件上绘图<br>图片框架控件指Frame类型的图片控件（Picture Control，一种静态文本框），可通过向对话框资源中添加图片控件，并设置其Type属性为Frame来得到。<br>可在对话框的绘图消息响应函数OnPaint或其他函数中，用CWnd类的成员函数GetDlgItem来获得图片控件的窗口对象，再用CWnd类的成员函数GetDC（原型为CDC<em> GetDC( );）由窗口对象得到绘图环境DC，然后就可以用该DC在控件中画图。例如（在ID为IDC_HUESAT的图片控件上画调色板）<br>void CPaletteDlg::OnPaint()<br>{<br>    ……<br>    CWnd </em>pWin = GetDlgItem(IDC_HUESAT);<br>    CDC <em>pDC = pWin-&gt;GetDC();<br>    ……<br>    pDC-&gt;SetPixel(i, j, RGB(r, g, b));<br>    ……<br>}<br>2．在其他控件上绘图<br>在非Frame类型静态控件上绘图，必须先按顺序依次调用CWnd类的Invalidate和UpdateWindow函数后，再开始用DC画图。例如，在一个按钮（IDC_COLOR）上绘图：<br>    CWnd</em> pWnd = GetDlgItem(IDC_COLOR); // 获取控件的窗口对象<br>    CDC<em> pDC = pWnd-&gt;GetDC(); // 获取控件的DC对象<br>    CRect rect; // 定义矩形对象<br>    pWnd-&gt;GetClientRect(&amp;rect); // 获取控件窗口的客户区矩形<br>    CBrush brush(m_crCol);  // 定义并创建刷对象(m_crCol为颜色类变量)<br>    pWnd-&gt;Invalidate(); // 使控件窗口无效<br>    pWnd-&gt;UpdateWindow(); // 更新控件窗口<br>    pDC-&gt;FillRect(&amp;rect, &amp;brush); // 绘制填充矩形<br>3．若干说明<br>下面是几点与控件上绘图有关的说明：<br>1)    为了使在运行时能够不断及时更新控件的显示（主要是自己加的显式代码），可以将自己绘制控件的所有代码都全部加入对话框类的消息响应函数OnPaint中。在需要时（例如在绘图参数修改后），自己调用CWnd的Invalidate和UpdateWindow函数，请求系统刷新对话框和控件的显示。因为控件也是窗口，传统的控件类都是CWnd的派生类。所以在对话框和控件中，可以像在视图类中一样，调用各种CWnd的成员函数。<br>2)    一般的对话框类，默认情况下都没有自动生成OnPaint函数。可以自己在对话框类中添加WM_PAINT消息的响应函数OnPaint来进行一些绘图工作。<br>3)    为了在鼠标指向按钮时，让按钮上自己绘制的图形不被消去，可以设置按钮控件的“Owner Draw”属性为“True”。<br>4)    如果希望非按钮控件（如图片控件和静态文本等），也可以响应鼠标消息（如单击、双击等），需要设置控件的“Notify”属性为“True”。<br>5)    使用OnPaint函数在对话框客户区的空白处（无控件的地方）绘制自己的图形，必须（利用注释符）屏蔽掉其中默认自动生成的对对话框基类的OnPaint函数的调用：<br>//CDialog::OnPaint();<br>6)    对话框的背景色，可以以COLOR_BTNFACE为数如参数调用CWnd类的成员函数GetSysColor得到，其函数原型为：<br>DWORD GetSysColor( int nIndex);<br>例如：<br>COLORREF col = GetSysColor(COLOR_BTNFACE);<br>可以在对话框资源中放置图片控件，并对其类型属性选Frame。可在对话框的绘图消息响应函数OnPaint或其他函数中，用CWnd类的函数GetDlgItem：<br>CWnd</em> GetDlgItem( int nID ) const;<br>来获得图片控件的窗口对象，再用函数GetDC：<br>CDC* GetDC( );<br>由窗口对象得到DC，然后就可以用该DC在控件中画图。如（在ID为IDC_HUESAT的图片控件上画调色板）。<br>4.综合实例<br>本实例要求建立一个MFC应用程序，点击菜单弹出一个对话框（非模态对话框），对话框上放置一个图片框，两个文本框（显示x,y坐标），两个滑动条（设置x,y坐标），要求移动滑动条，相应坐标显示在两个文本框内，同时在图片框内实时按照设置的坐标绘制直线。<br>步骤如下：<br>（1）建立MFC项目：项目名字为pictu。<br>（2）添加菜单，绘图-滑块图片框画直线<br>（3）添加对话框并在对话框上添加相应控件<br>（4）添加代码<br>（5）编译运行<br>8.6 文本绘制</p>
<p>CFont</p>
<p>CPalette</p>
<p>8.7 位图<br>CBitmap</p>
<p>8.8 图标和光标<br>CRgn</p>
<p>8.9 图像处理</p>
<p>9 文件处理</p>
<p>10 数据库编程</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/09/15/网页CSS按钮展示/" rel="next" title="网页CSS按钮">
                <i class="fa fa-chevron-left"></i> 网页CSS按钮
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/09/21/秘密花园/" rel="prev" title="秘密花园">
                秘密花园 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="lewyu" />
          <p class="site-author-name" itemprop="name">lewyu</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="lewyu" target="_blank" title="github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      github
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lewyu</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
